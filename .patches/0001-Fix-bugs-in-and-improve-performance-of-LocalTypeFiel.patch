From 2996c0f689036e0ac757322c7ba88cb728aebfec Mon Sep 17 00:00:00 2001
From: Mark Sandstrom <marksandstrom@khanacademy.org>
Date: Mon, 1 Nov 2021 16:00:00 -0700
Subject: [PATCH 1/2] Fix bugs in and improve performance of
 LocalTypeFieldExtractor

This PR fixes several bugs in the LocalTypeFieldExtractor GetAllNodes
method. It also drastically improves the performance of the code. Tests
and a benchmark for the updated code were added in #297. Details of the
node extraction algorithm are described inline.

See the updated and uncommented tests for details about the fixed bugs
(and well as the fixed issues linked below).

The benchmark for the updated code is as follows:
```
$ cd pkg/engine/plan
$ go test -bench=. -run=xxxx
goos: darwin
goarch: amd64
pkg: github.com/jensneuse/graphql-go-tools/pkg/engine/plan
BenchmarkGetAllNodes-8  53476  22360 ns/op  10804 B/op  173 allocs/op
PASS
ok  github.com/jensneuse/graphql-go-tools/pkg/engine/plan  1.872s
```

This is a 500x speedup over the previous implementation (the prior
benchmark results can be found in #297).

Fixes #293 and #294.
---
 pkg/ast/ast_node.go                           |   8 +-
 pkg/engine/plan/local_type_field_extractor.go | 364 +++++++++++-------
 .../plan/local_type_field_extractor_test.go   |  14 +-
 pkg/graphql/config_factory_federation_test.go |   8 +-
 4 files changed, 226 insertions(+), 168 deletions(-)

diff --git a/pkg/ast/ast_node.go b/pkg/ast/ast_node.go
index aa3dd433..db73b078 100644
--- a/pkg/ast/ast_node.go
+++ b/pkg/ast/ast_node.go
@@ -29,7 +29,6 @@ func (n *Node) IsExtensionKind() bool {
 }
 
 func (d *Document) NodeNameBytes(node Node) ByteSlice {
-
 	var ref ByteSliceReference
 
 	switch node.Kind {
@@ -55,6 +54,8 @@ func (d *Document) NodeNameBytes(node Node) ByteSlice {
 		ref = d.ObjectTypeExtensions[node.Ref].Name
 	case NodeKindInterfaceTypeExtension:
 		ref = d.InterfaceTypeExtensions[node.Ref].Name
+	case NodeKindUnionTypeExtension:
+		ref = d.UnionTypeExtensions[node.Ref].Name
 	case NodeKindEnumTypeExtension:
 		ref = d.EnumTypeExtensions[node.Ref].Name
 	}
@@ -336,7 +337,6 @@ func (d *Document) InputValueDefinitionIsLast(inputValue int, ancestor Node) boo
 // Node misc
 
 func (d *Document) NodeImplementsInterface(node Node, interfaceNode Node) bool {
-
 	nodeFields := d.NodeFieldDefinitions(node)
 	interfaceFields := d.NodeFieldDefinitions(interfaceNode)
 
@@ -384,7 +384,6 @@ func (d *Document) RemoveNodeFromNode(remove, from Node) {
 }
 
 func (d *Document) RemoveNodeFromSelectionSet(set int, node Node) {
-
 	var selectionKind SelectionKind
 
 	switch node.Kind {
@@ -423,7 +422,6 @@ func (d *Document) NodeFragmentIsAllowedOnNode(fragmentNode, onNode Node) bool {
 }
 
 func (d *Document) NodeFragmentIsAllowedOnInterfaceTypeDefinition(fragmentNode, interfaceTypeNode Node) bool {
-
 	switch fragmentNode.Kind {
 	case NodeKindObjectTypeDefinition:
 		return d.NodeImplementsInterface(fragmentNode, interfaceTypeNode)
@@ -437,7 +435,6 @@ func (d *Document) NodeFragmentIsAllowedOnInterfaceTypeDefinition(fragmentNode,
 }
 
 func (d *Document) NodeFragmentIsAllowedOnUnionTypeDefinition(fragmentNode, unionTypeNode Node) bool {
-
 	switch fragmentNode.Kind {
 	case NodeKindObjectTypeDefinition:
 		return d.NodeIsUnionMember(fragmentNode, unionTypeNode)
@@ -451,7 +448,6 @@ func (d *Document) NodeFragmentIsAllowedOnUnionTypeDefinition(fragmentNode, unio
 }
 
 func (d *Document) NodeFragmentIsAllowedOnObjectTypeDefinition(fragmentNode, objectTypeNode Node) bool {
-
 	switch fragmentNode.Kind {
 	case NodeKindObjectTypeDefinition:
 		return bytes.Equal(d.ObjectTypeDefinitionNameBytes(fragmentNode.Ref), d.ObjectTypeDefinitionNameBytes(objectTypeNode.Ref))
diff --git a/pkg/engine/plan/local_type_field_extractor.go b/pkg/engine/plan/local_type_field_extractor.go
index 786aca5b..904267b7 100644
--- a/pkg/engine/plan/local_type_field_extractor.go
+++ b/pkg/engine/plan/local_type_field_extractor.go
@@ -2,10 +2,6 @@ package plan
 
 import (
 	"github.com/jensneuse/graphql-go-tools/pkg/ast"
-	"github.com/jensneuse/graphql-go-tools/pkg/astparser"
-	"github.com/jensneuse/graphql-go-tools/pkg/astprinter"
-	"github.com/jensneuse/graphql-go-tools/pkg/asttransform"
-	"github.com/jensneuse/graphql-go-tools/pkg/federation"
 )
 
 const (
@@ -14,11 +10,15 @@ const (
 	federationExternalDirectiveName = "external"
 )
 
-// LocalTypeFieldExtractor takes an ast.Document as input
-// and generates the TypeField configuration for both root fields & child fields
-// If a type is a federation entity (annotated with @key directive)
-// and a field is is extended, this field will be skipped
-// so that only "local" fields will be generated
+// LocalTypeFieldExtractor takes an ast.Document as input and generates the
+// TypeField configuration for both root and child nodes. Root nodes are the
+// root operation types (usually Query, Mutation and Schema--though these types
+// can be configured via the schema keyword) plus "entities" as defined by the
+// Apollo federation specification. In short, entities are types with a @key
+// directive. Child nodes are field types recursively accessible via a root
+// node. Nodes are either object or interface definitions or extensions. Root
+// nodes only include "local" fields; they don't include fields that have the
+// @external directive.
 type LocalTypeFieldExtractor struct {
 	document *ast.Document
 }
@@ -27,191 +27,263 @@ func NewLocalTypeFieldExtractor(document *ast.Document) *LocalTypeFieldExtractor
 	return &LocalTypeFieldExtractor{document: document}
 }
 
-// GetAllNodes returns all Root- & ChildNodes
-func (e *LocalTypeFieldExtractor) GetAllNodes() (rootNodes, childNodes []TypeField) {
-	rootNodes = e.getAllRootNodes()
-	childNodes = e.getAllChildNodes(rootNodes)
-	return
+type nodeInformation struct {
+	isInterface       bool
+	isRoot            bool
+	concreteTypeNames []string
+	localFieldRefs    []int
+	externalFieldRefs []int
 }
 
-func (e *LocalTypeFieldExtractor) getAllRootNodes() []TypeField {
-	var rootNodes []TypeField
-
-	for _, astNode := range e.document.RootNodes {
-		switch astNode.Kind {
-		case ast.NodeKindObjectTypeExtension, ast.NodeKindObjectTypeDefinition:
-			e.addRootNodes(astNode, &rootNodes)
+// appendIfNotPresent appends a string to the given slice if the string isn't
+// already present in the slice.
+func appendIfNotPresent(slice []string, value string) []string {
+	var hasValue bool
+	for _, existingValue := range slice {
+		if value == existingValue {
+			hasValue = true
+			break
 		}
 	}
-
-	return rootNodes
+	if !hasValue {
+		return append(slice, value)
+	}
+	return slice
 }
 
-func (e *LocalTypeFieldExtractor) getAllChildNodes(rootNodes []TypeField) []TypeField {
-	var childNodes []TypeField
+// GetAllNodes returns all root and child nodes in the document associated with
+// the LocalTypeFieldExtractor. See LocalTypeFieldExtractor for a detailed
+// explanation of what root and child nodes are.
+func (e *LocalTypeFieldExtractor) GetAllNodes() ([]TypeField, []TypeField) {
+	// The strategy for the extractor is as follows:
+	//
+	// 1. Loop over each node in the document and collect information into
+	//    "node info" structs. All document nodes are processed before creating
+	//    the final "root" and "child" plan nodes because multiple document
+	//    nodes may correspond to a single "node info" struct. For example,
+	//    `type User { ... }` and `extend type User { ... }` nodes will
+	//    correspond to a single User struct.
+	//
+	// 2. Build root nodes for each node info struct identified as a root node.
+	//
+	// 3. Push the root node info structs into a queue and construct a child
+	//    node for each info struct in the queue. After constructing a child
+	//    node, loop over the fields of the child type and add any object or
+	//    abstract type to the queue if the type hasn't yet been processed. An
+	//    abstract type is either an interface or union. When processing
+	//    abstract types, also add the corresponding concrete types to the
+	//    queue (i.e. all the types that implement an interface and union
+	//    members). Note that child nodes aren't created for union types--only
+	//    union members--since it ISN'T possible to select directly from a
+	//    union; union selection sets MUST contain fragments.
+
+	nodeInfoMap := make(map[string]*nodeInformation, len(e.document.RootNodes))
+	possibleInterfaceTypes := map[string][]string{}
+	var rootNodeNames []string
+
+	// https://spec.graphql.org/June2018/#sec-Root-Operation-Types
+	queryType := string(e.document.Index.QueryTypeName)
+	if queryType == "" {
+		queryType = "Query"
+	}
+	mutationType := string(e.document.Index.MutationTypeName)
+	if mutationType == "" {
+		mutationType = "Mutation"
+	}
+	subscriptionType := string(e.document.Index.SubscriptionTypeName)
+	if subscriptionType == "" {
+		subscriptionType = "Subscription"
+	}
 
-	for i := range rootNodes {
-		fieldNameToRef := make(map[string]int, len(rootNodes[i].FieldNames))
+	// 1. Loop over each node in the document (see description above).
+	for _, astNode := range e.document.RootNodes {
+		var isInterface bool
+		var concreteTypeNames []string
+		typeName := e.document.NodeNameString(astNode)
 
-		rootNodeASTNode, exists := e.document.Index.FirstNodeByNameStr(rootNodes[i].TypeName)
-		if !exists {
+		switch astNode.Kind {
+		case ast.NodeKindObjectTypeDefinition, ast.NodeKindObjectTypeExtension:
+			for _, ref := range e.interfaceRefs(astNode) {
+				interfaceName := e.document.ResolveTypeNameString(ref)
+				// The document doesn't provide a way to directly look up the
+				// types that implement an interface, so instead we track the
+				// interfaces implemented for each type and after all nodes
+				// have been processed record the concrete types for each
+				// interface.
+				possibleInterfaceTypes[interfaceName] = append(
+					possibleInterfaceTypes[interfaceName], typeName)
+			}
+		case ast.NodeKindInterfaceTypeDefinition, ast.NodeKindInterfaceTypeExtension:
+			isInterface = true
+		case ast.NodeKindUnionTypeDefinition, ast.NodeKindUnionTypeExtension:
+			for _, ref := range e.unionMemberRefs(astNode) {
+				memberName := e.document.ResolveTypeNameString(ref)
+				concreteTypeNames = append(concreteTypeNames, memberName)
+			}
+		default:
 			continue
 		}
 
-		fieldRefs := e.document.NodeFieldDefinitions(rootNodeASTNode)
-		for _, fieldRef := range fieldRefs {
-			fieldName := e.document.FieldDefinitionNameString(fieldRef)
-			fieldNameToRef[fieldName] = fieldRef
+		nodeInfo, ok := nodeInfoMap[typeName]
+		if !ok {
+			nodeInfo = &nodeInformation{}
+			nodeInfoMap[typeName] = nodeInfo
 		}
 
-		for _, fieldName := range rootNodes[i].FieldNames {
-			fieldRef := fieldNameToRef[fieldName]
-
-			fieldTypeName := e.document.NodeNameString(e.document.FieldDefinitionTypeNode(fieldRef))
-			e.findChildNodesForType(fieldTypeName, &childNodes)
-		}
-	}
+		hasKey := e.NodeHasKeyDirective(astNode)
+		isFederationEntity := hasKey && !isInterface
 
-	return childNodes
-}
+		isRootNode := typeName == queryType ||
+			typeName == mutationType ||
+			typeName == subscriptionType ||
+			isFederationEntity
 
-func (e *LocalTypeFieldExtractor) findChildNodesForType(typeName string, childNodes *[]TypeField) {
-	node, exists := e.document.Index.FirstNodeByNameStr(typeName)
-	if !exists {
-		return
-	}
+		nodeInfo.isInterface = isInterface
+		// A node may be a local extension of a root node. The node is
+		// considered a root node if ANY node related to the type is a root
+		// node.
+		nodeInfo.isRoot = nodeInfo.isRoot || isRootNode
+		nodeInfo.concreteTypeNames = concreteTypeNames
 
-	switch node.Kind {
-	case ast.NodeKindUnionTypeDefinition:
-		for _, ref := range e.document.UnionTypeDefinitions[node.Ref].UnionMemberTypes.Refs {
-			fieldTypeName := e.document.TypeNameString(ref)
-			e.findChildNodesForType(fieldTypeName, childNodes)
+		if isRootNode {
+			rootNodeNames = appendIfNotPresent(rootNodeNames, typeName)
 		}
 
-		return
-
-	case ast.NodeKindInterfaceTypeDefinition:
-		for ref := range e.document.ObjectTypeDefinitions {
-			if e.document.ObjectTypeDefinitionImplementsInterface(ref, e.document.InterfaceTypeDefinitionNameBytes(node.Ref)) {
-				typeName := e.document.ObjectTypeDefinitionNameString(ref)
-				e.findChildNodesForType(typeName, childNodes)
+		// Record the local and external fields separately for later
+		// processing. Root nodes only include local fields, while child nodes
+		// include both local and external fields.
+		for _, ref := range e.document.NodeFieldDefinitions(astNode) {
+			isExternal := e.document.FieldDefinitionHasNamedDirective(ref,
+				federationExternalDirectiveName)
+
+			if isExternal {
+				nodeInfo.externalFieldRefs = append(nodeInfo.externalFieldRefs, ref)
+			} else {
+				nodeInfo.localFieldRefs = append(nodeInfo.localFieldRefs, ref)
 			}
 		}
 	}
 
-	fieldsRefs := e.document.NodeFieldDefinitions(node)
-
-	for _, fieldRef := range fieldsRefs {
-		fieldName := e.document.FieldDefinitionNameString(fieldRef)
-
-		if added := e.addChildTypeFieldName(typeName, fieldName, childNodes); !added {
-			continue
+	// Record the concrete types for each interface.
+	for interfaceName, concreteTypeNames := range possibleInterfaceTypes {
+		if nodeInfo, ok := nodeInfoMap[interfaceName]; ok {
+			nodeInfo.concreteTypeNames = concreteTypeNames
 		}
-
-		fieldTypeName := e.document.NodeNameString(e.document.FieldDefinitionTypeNode(fieldRef))
-		e.findChildNodesForType(fieldTypeName, childNodes)
 	}
-}
 
-func (e *LocalTypeFieldExtractor) addChildTypeFieldName(typeName, fieldName string, childNodes *[]TypeField) bool {
-	for i := range *childNodes {
-		if (*childNodes)[i].TypeName != typeName {
-			continue
-		}
-
-		for _, field := range (*childNodes)[i].FieldNames {
-			if field == fieldName {
-				return false
+	// This is the queue used in step 3, child node construction.
+	childrenSeen := make(map[string]struct{}, len(nodeInfoMap))
+	childrenToProcess := make([]string, 0, len(nodeInfoMap))
+
+	// pushChildIfNotAlreadyProcessed pushes a child type onto the queue if it
+	// hasn't already been processed. Only types with node info are pushed onto
+	// the queue. Recall that node info is limited to object types, interfaces
+	// and union members above.
+	pushChildIfNotAlreadyProcessed := func(typeName string) {
+		if _, ok := childrenSeen[typeName]; !ok {
+			if _, ok := nodeInfoMap[typeName]; ok {
+				childrenToProcess = append(childrenToProcess, typeName)
 			}
+			childrenSeen[typeName] = struct{}{}
 		}
-
-		(*childNodes)[i].FieldNames = append((*childNodes)[i].FieldNames, fieldName)
-		return true
 	}
 
-	*childNodes = append(*childNodes, TypeField{
-		TypeName:   typeName,
-		FieldNames: []string{fieldName},
-	})
-
-	return true
-}
-
-func (e *LocalTypeFieldExtractor) addRootNodes(astNode ast.Node, rootNodes *[]TypeField) {
-	typeName := e.document.NodeNameString(astNode)
-
-	// we need to first build the base schema so that we get a valid Index
-	// to look up if typeName is a RootOperationTypeName
-	// the service SDL itself might use ObjectTypeExtension types which will not be indexed
-	document := e.baseSchema()
-
-	// node should be an entity or a root operation type definition
-	// if document == nil, there are no root operation type definitions in this document
-	if !e.isEntity(astNode) && (document == nil || !document.Index.IsRootOperationTypeNameString(typeName)) {
-		return
+	// processFieldRef pushes node info for the field's type as well as--in the
+	// case of abstract types--node info for each concrete type.
+	processFieldRef := func(ref int) string {
+		fieldType := e.document.FieldDefinitionType(ref)
+		fieldTypeName := e.document.ResolveTypeNameString(fieldType)
+		pushChildIfNotAlreadyProcessed(fieldTypeName)
+		if nodeInfo, ok := nodeInfoMap[fieldTypeName]; ok {
+			for _, name := range nodeInfo.concreteTypeNames {
+				pushChildIfNotAlreadyProcessed(name)
+			}
+		}
+		return e.document.FieldDefinitionNameString(ref)
 	}
 
-	var fieldNames []string
+	var rootNodes, childNodes []TypeField
 
-	fieldRefs := e.document.NodeFieldDefinitions(astNode)
-	for _, fieldRef := range fieldRefs {
-		// check if field definition is external (has external directive)
-		if e.document.FieldDefinitionHasNamedDirective(fieldRef, federationExternalDirectiveName) {
+	// 2. Create the root nodes. Also, loop over the fields to find additional
+	// child nodes to process.
+	for _, typeName := range rootNodeNames {
+		nodeInfo := nodeInfoMap[typeName]
+		numFields := len(nodeInfo.localFieldRefs)
+		if numFields == 0 {
 			continue
 		}
-
-		fieldName := e.document.FieldDefinitionNameString(fieldRef)
-		fieldNames = append(fieldNames, fieldName)
+		fieldNames := make([]string, numFields)
+		for i, ref := range nodeInfo.localFieldRefs {
+			fieldNames[i] = processFieldRef(ref)
+		}
+		rootNodes = append(rootNodes, TypeField{
+			TypeName:   typeName,
+			FieldNames: fieldNames,
+		})
 	}
 
-	if len(fieldNames) == 0 {
-		return
+	// 3. Process the child node queue to create child nodes. When processing
+	// child nodes, loop over the fields of the child to find additional
+	// children to process.
+	for len(childrenToProcess) > 0 {
+		typeName := childrenToProcess[len(childrenToProcess)-1]
+		childrenToProcess = childrenToProcess[:len(childrenToProcess)-1]
+		nodeInfo, ok := nodeInfoMap[typeName]
+		if !ok {
+			continue
+		}
+		numFields := len(nodeInfo.localFieldRefs) + len(nodeInfo.externalFieldRefs)
+		if numFields == 0 {
+			continue
+		}
+		fieldNames := make([]string, 0, numFields)
+		for _, ref := range nodeInfo.localFieldRefs {
+			fieldNames = append(fieldNames, processFieldRef(ref))
+		}
+		for _, ref := range nodeInfo.externalFieldRefs {
+			fieldNames = append(fieldNames, processFieldRef(ref))
+		}
+		childNodes = append(childNodes, TypeField{
+			TypeName:   typeName,
+			FieldNames: fieldNames,
+		})
 	}
 
-	*rootNodes = append(*rootNodes, TypeField{
-		TypeName:   typeName,
-		FieldNames: fieldNames,
-	})
+	return rootNodes, childNodes
 }
 
-func (e *LocalTypeFieldExtractor) baseSchema() *ast.Document {
-	schemaSDL, err := astprinter.PrintString(e.document, nil)
-	if err != nil {
-		return nil
-	}
-	baseSchemaSDL, err := federation.BuildBaseSchemaDocument(schemaSDL)
-	if err != nil {
-		return nil
-	}
-	document, report := astparser.ParseGraphqlDocumentString(baseSchemaSDL)
-	if report.HasErrors() {
-		return nil
-	}
-	err = asttransform.MergeDefinitionWithBaseSchema(&document)
-	if err != nil {
-		return nil
-	}
-	mergedSDL, err := astprinter.PrintString(&document, nil)
-	if err != nil {
+// interfaceRefs returns the interfaces implemented by the given node (this is
+// only applicable to object kinds).
+func (e *LocalTypeFieldExtractor) interfaceRefs(node ast.Node) []int {
+	switch node.Kind {
+	case ast.NodeKindObjectTypeDefinition:
+		return e.document.ObjectTypeDefinitions[node.Ref].ImplementsInterfaces.Refs
+	case ast.NodeKindObjectTypeExtension:
+		return e.document.ObjectTypeExtensions[node.Ref].ImplementsInterfaces.Refs
+	default:
 		return nil
 	}
-	mergedDocument, report := astparser.ParseGraphqlDocumentString(mergedSDL)
-	if report.HasErrors() {
+}
+
+// unionMemberRefs returns the union members of the given node (this is only
+// applicable to union kinds).
+func (e *LocalTypeFieldExtractor) unionMemberRefs(node ast.Node) []int {
+	switch node.Kind {
+	case ast.NodeKindUnionTypeDefinition:
+		return e.document.UnionTypeDefinitions[node.Ref].UnionMemberTypes.Refs
+	case ast.NodeKindUnionTypeExtension:
+		return e.document.UnionTypeExtensions[node.Ref].UnionMemberTypes.Refs
+	default:
 		return nil
 	}
-	return &mergedDocument
 }
 
-// isEntity checks if node is an Entity according to the federation spec
-// by checking if it is annotated with the "key" directive
-func (e *LocalTypeFieldExtractor) isEntity(astNode ast.Node) bool {
-	directiveRefs := e.document.NodeDirectives(astNode)
-
-	for _, directiveRef := range directiveRefs {
-		if directiveName := e.document.DirectiveNameString(directiveRef); directiveName == federationKeyDirectiveName {
+// NodeHasKeyDirective returns whether the given node has a @key directive.
+func (e *LocalTypeFieldExtractor) NodeHasKeyDirective(node ast.Node) bool {
+	for _, directiveRef := range e.document.NodeDirectives(node) {
+		if e.document.DirectiveNameString(directiveRef) == federationKeyDirectiveName {
 			return true
 		}
 	}
-
 	return false
 }
diff --git a/pkg/engine/plan/local_type_field_extractor_test.go b/pkg/engine/plan/local_type_field_extractor_test.go
index 107c57c2..d1870f4f 100644
--- a/pkg/engine/plan/local_type_field_extractor_test.go
+++ b/pkg/engine/plan/local_type_field_extractor_test.go
@@ -303,14 +303,10 @@ func TestLocalTypeFieldExtractor_GetAllNodes(t *testing.T) {
 				{TypeName: "Review", FieldNames: []string{"comment", "rating", "user"}},
 			},
 			[]TypeField{
+				{TypeName: "Comment", FieldNames: []string{"comment", "id", "user"}},
 				{TypeName: "Communication", FieldNames: []string{"comment", "id", "user"}},
+				{TypeName: "Review", FieldNames: []string{"comment", "id", "rating", "user"}},
 				{TypeName: "User", FieldNames: []string{"communications", "id"}},
-				// Bug: The concrete types that implement an interface should
-				// also be included. Uncomment these lines once the bug is
-				// fixed.
-				//
-				// {TypeName: "Comment", FieldNames: []string{"comment", "id", "user"}},
-				// {TypeName: "Review", FieldNames: []string{"comment", "id", "rating", "user"}},
 			})
 	})
 	t.Run("union", func(t *testing.T) {
@@ -351,8 +347,6 @@ func TestLocalTypeFieldExtractor_GetAllNodes(t *testing.T) {
 			})
 	})
 	t.Run("extended union", func(t *testing.T) {
-		t.Skip("Union members should be included as child nodes, but they currently aren't. Un-skip this test once they are.")
-
 		run(t, `
 			extend type Query {
 				me: User
@@ -510,8 +504,6 @@ func TestLocalTypeFieldExtractor_GetAllNodes(t *testing.T) {
 			})
 	})
 	t.Run("local type extension", func(t *testing.T) {
-		t.Skip("The existing LocalTypeFieldExtractor can't handle local type extensions. Un-skip this test once it can.")
-
 		run(t, `
            extend type Query {
                    reviews(IDs: [ID!]!): [Review!]
@@ -556,8 +548,6 @@ func TestLocalTypeFieldExtractor_GetAllNodes(t *testing.T) {
 			})
 	})
 	t.Run("local type extension defined before local type", func(t *testing.T) {
-		t.Skip("The existing LocalTypeFieldExtractor can't handle local type extensions. Un-skip this test once it can.")
-
 		run(t, `
            extend type Query {
                    reviews(IDs: [ID!]!): [Review!]
diff --git a/pkg/graphql/config_factory_federation_test.go b/pkg/graphql/config_factory_federation_test.go
index 95cefc6f..9f0539b9 100644
--- a/pkg/graphql/config_factory_federation_test.go
+++ b/pkg/graphql/config_factory_federation_test.go
@@ -198,12 +198,12 @@ func TestEngineConfigV2Factory_EngineV2Configuration(t *testing.T) {
 							FieldNames: []string{"body", "author", "product"},
 						},
 						{
-							TypeName:   "User",
-							FieldNames: []string{"id", "username", "reviews"},
+							TypeName:   "Product",
+							FieldNames: []string{"reviews", "upc"},
 						},
 						{
-							TypeName:   "Product",
-							FieldNames: []string{"upc", "reviews"},
+							TypeName:   "User",
+							FieldNames: []string{"reviews", "id", "username"},
 						},
 					},
 					Factory: &graphqlDataSource.Factory{
-- 
2.25.1

