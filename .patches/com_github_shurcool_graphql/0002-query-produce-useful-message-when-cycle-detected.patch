diff --git a/query.go b/query.go
index 97cf3a5..a4e9972 100644
--- a/query.go
+++ b/query.go
@@ -7,6 +7,7 @@ import (
 	"io"
 	"reflect"
 	"sort"
+	"strings"

 	"github.com/shurcooL/graphql/ident"
 )
@@ -89,7 +90,7 @@ func writeArgumentType(w io.Writer, t reflect.Type, value bool) {
 // E.g., struct{Foo Int, BarBaz *Boolean} -> "{foo,barBaz}".
 func query(v interface{}) string {
 	var buf bytes.Buffer
-	writeQuery(&buf, reflect.TypeOf(v), map[edge]int{}, false)
+	writeQuery(&buf, reflect.TypeOf(v), map[edge]int{}, []string{}, false)
 	return buf.String()
 }

@@ -102,10 +103,10 @@ type edge struct {

 // writeQuery writes a minified query for t to w.
 // If inline is true, the struct fields of t are inlined into parent struct.
-func writeQuery(w io.Writer, t reflect.Type, visited map[edge]int, inline bool) {
+func writeQuery(w io.Writer, t reflect.Type, visited map[edge]int, visitPath []string, inline bool) {
 	switch t.Kind() {
 	case reflect.Ptr, reflect.Slice:
-		writeQuery(w, t.Elem(), visited, false)
+		writeQuery(w, t.Elem(), visited, visitPath, false)
 	case reflect.Struct:
 		// If the type implements json.Unmarshaler, it's a scalar. Don't expand it.
 		if reflect.PtrTo(t).Implements(jsonUnmarshaler) {
@@ -124,7 +125,8 @@ func writeQuery(w io.Writer, t reflect.Type, visited map[edge]int, inline bool)
 			edge := edge{t, i}
 			visited[edge]++
 			if visited[edge] > 1 {
-				panic(fmt.Errorf("cycle found"))
+				visitPath = append(visitPath, t.Name())
+				panic(fmt.Errorf("cycle found: %s", strings.Join(visitPath, "->")))
 			}

 			value, ok := f.Tag.Lookup("graphql")
@@ -136,7 +138,9 @@ func writeQuery(w io.Writer, t reflect.Type, visited map[edge]int, inline bool)
 					io.WriteString(w, ident.ParseMixedCaps(f.Name).ToLowerCamelCase())
 				}
 			}
-			writeQuery(w, f.Type, visited, inlineField)
+			visitPath = append(visitPath, t.String()+"."+f.Name)
+			writeQuery(w, f.Type, visited, visitPath, inlineField)
+			visitPath = visitPath[:len(visitPath)-1]
 			visited[edge]--
 		}
 		if !inline {
diff --git a/query_test.go b/query_test.go
index e195fb2..a07d824 100644
--- a/query_test.go
+++ b/query_test.go
@@ -334,7 +334,33 @@ func TestConstructRecursiveQuery(t *testing.T) {
 				t.Errorf("\ngot:  %q\nwant: an error!\n", got)
 			}
 		})
-		expect := fmt.Errorf("cycle found")
+		expect := fmt.Errorf("cycle found: graphql.Recurser.Children->Recurser")
+		if err.Error() != expect.Error() {
+			t.Errorf("\ngot err:  %q\nwant err: %q\n", err, expect)
+		}
+	})
+	t.Run("deeper recursions should panic with helpful path info", func(t *testing.T) {
+		// A nested anonymous struct is used because function-local types require
+		// defining *in order*, so we can't make multi-step recursions out of them.
+		type Recurser struct {
+			LeafB    string
+			Children []struct {
+				Cycle Recurser
+			}
+			LeafC string
+		}
+		type Parent struct {
+			LeafA    string
+			Children []Recurser
+			LeafD    string
+		}
+		err := gatherPanic(func() {
+			got := query(Parent{})
+			if got != "" {
+				t.Errorf("\ngot:  %q\nwant: an error!\n", got)
+			}
+		})
+		expect := fmt.Errorf("cycle found: graphql.Parent.Children->graphql.Recurser.Children->struct { Cycle graphql.Recurser }.Cycle->Recurser")
 		if err.Error() != expect.Error() {
 			t.Errorf("\ngot err:  %q\nwant err: %q\n", err, expect)
 		}
--
2.25.1

