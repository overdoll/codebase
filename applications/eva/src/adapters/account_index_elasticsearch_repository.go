package adapters

import (
	"context"
	"encoding/json"
	"fmt"
	"math"

	"github.com/scylladb/gocqlx/v2"
	"golang.org/x/sync/errgroup"
	"overdoll/applications/eva/src/domain/account"
	search "overdoll/libraries/elasticsearch"
	"overdoll/libraries/paging"
)

//"""ID representing the account"""
//id: ID!
//
//"""The ID that the account can be referenced by"""
//reference: String!
//
//"""A URL pointing to the Accounts's public avatar."""
//avatar(
//"""The size of the resulting square image."""
//size: Int
//): URI!
//
//"""The username of the account."""
//username: String!
//
//"""Whether or not this account is a staff member"""
//isStaff: Boolean!
//
//"""Whether or not this account is part of the moderation team"""
//isModerator: Boolean!
//
//"""Whether or not this account is an artist"""
//isArtist: Boolean!
//
//"""Whether or not this account is locked"""
//isLocked: Boolean!
//
//"""The details of the account lock"""
//lockDetails: AccountLockDetails

type accountDocument struct {
	Id       string   `json:"id"`
	Avatar   string   `json:"avatar"`
	Username string   `json:"username"`
	Verified bool     `json:"verified"`
	Roles    []string `json:"roles"`
}

const accountIndex = `
{
	"mappings": {
		"dynamic": "strict",
		"properties": {
			"id": {
				"type": "keyword"
			},
			"avatar": {
				"type": "keyword"
			},
			"username": {
				"type": "text",
				"analyzer": "english"
			},
			"verified": {
				"type": "bool",
			},
			"Roles": {
				"type": "bool",
			}
		}
	}
}`

const searchAccounts = `
	"query" : {
		"multi_match" : {
			"query" : %q,
			"fields" : ["username^100"],
			"operator" : "and"
		}
	},
	"size" : 5`

const allAccounts = `
	"query" : { "match_all" : {} },
	"size" : 5`

const accountIndexName = "Accounts"

type AccountIndexElasticSearchRepository struct {
	session gocqlx.Session
	store   *search.Store
}

func NewAccountIndexElasticSearchRepository(session gocqlx.Session, store *search.Store) AccountIndexElasticSearchRepository {
	return AccountIndexElasticSearchRepository{session: session, store: store}
}

func (r AccountIndexElasticSearchRepository) SearchAccounts(ctx context.Context, cursor *paging.Cursor, username string, artist bool) ([]*account.Account, *paging.Info, error) {
	var query string

	if username == "" {
		query = allAccounts
	} else {
		query = fmt.Sprintf(searchAccounts, query)
	}

	response, err := r.store.Search(accountIndexName, query)

	if err != nil {
		return nil, nil, err
	}

	var accounts []*account.Account

	for _, cat := range response.Hits {

		var ac accountDocument

		err := json.Unmarshal(cat, &ac)

		if err != nil {
			return nil, nil, err
		}

		// note that the index only contains partial info for the account so it should never be used for domain objects
		acc := account.UnmarshalAccountFromDatabase(ac.Id, ac.Username, "", ac.Roles, ac.Verified, ac.Avatar, false, 0, "", false)
		acc.Node = paging.NewNode(ac.Id)

		accounts = append(accounts, acc)

	}

	return accounts, nil, nil
}

// Efficiently scan the accounts table and index it
func (r AccountIndexElasticSearchRepository) BulkIndexAccounts(ctx context.Context) error {

	var (
		nodesInCluster = 1
		coresInNode    = 1
		smudgeFactor   = 3
	)

	workers := nodesInCluster * coresInNode * smudgeFactor

	type tokenRange struct {
		Start int64
		End   int64
	}
	buf := make(chan tokenRange)

	// sequencer pushes token ranges to buf
	sequencer := func() error {
		span := int64(math.MaxInt64 / (50 * workers))

		tr := tokenRange{math.MinInt64, math.MinInt64 + span}
		for tr.End > tr.Start {
			buf <- tr
			tr.Start = tr.End
			tr.End += span
		}

		tr.End = math.MaxInt64
		buf <- tr
		close(buf)

		return nil
	}

	// worker queries a token ranges generated by sequencer
	worker := func() error {

		const cql = `SELECT * FROM accounts WHERE 
			token(id) >= :start AND 
			token(id) < :end`

		stmt, names, err := gocqlx.CompileNamedQueryString(cql)
		if err != nil {
			return err
		}

		q := r.session.Query(stmt, names)
		defer q.Release()

		var a Accounts
		for {
			tr, ok := <-buf
			if !ok {
				break
			}

			iter := q.BindStruct(tr).Iter()

			if err := r.store.CreateBulkIndex(accountIndex); err != nil {
				_ = iter.Close()
				return err
			}

			for iter.StructScan(&a) {
				err = r.store.AddToBulkIndex(a.Id, accountDocument{
					Id:       a.Id,
					Avatar:   a.Avatar,
					Username: a.Username,
					Verified: a.Verified,
					Roles:    a.Roles,
				})
			}

			if err := r.store.CloseBulkIndex(); err != nil {
				_ = iter.Close()
				return fmt.Errorf("unexpected error: %s", err)
			}

			if err := iter.Close(); err != nil {
				return err
			}
		}

		return nil
	}

	// Query and displays data.

	var wg errgroup.Group
	wg.Go(sequencer)
	for i := 0; i < workers; i++ {
		wg.Go(worker)
	}

	if err := wg.Wait(); err != nil {
		return err
	}

	return nil
}

func (r AccountIndexElasticSearchRepository) DeleteAccountIndex(ctx context.Context) error {
	err := r.store.DeleteIndex(accountIndexName)

	if err != nil {

	}

	err = r.store.CreateIndex(accountIndexName, accountIndex)

	if err != nil {
		return fmt.Errorf("failed to create account index: %s", err)
	}

	return nil
}
