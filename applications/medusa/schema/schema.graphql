type Account implements Node {
  id: ID!
  username: String!
  roles: [AccountRoleEnum!]!
  avatar: String!
  verified: Boolean!
  lock: AccountLock
  testField: String!
}

type AccountEmail {
  email: String!
  status: AccountEmailStatusEnum!
}

enum AccountEmailStatusEnum {
  CONFIRMED
  UNCONFIRMED
  PRIMARY
}

type AccountGeneralSettings {
  """Emails for account (multiple emails per account)"""
  emails: [AccountEmail!]!

  """Usernames for account (history)"""
  usernames: [AccountUsername!]!
}

type AccountInfractionHistory {
  id: String!
  reason: String!
}

type AccountLock {
  expires: Int!
  reason: AccountLockReasonEnum!
}

enum AccountLockReasonEnum {
  PostInfraction
}

type AccountModeratorSettings {
  inQueue: Boolean!
}

type AccountMultiFactorRecoveryCode {
  code: String!
}

type AccountMultiFactorSecuritySettings {
  """
  Have recovery codes been generated? Required in order to configure TOTP
  """
  recoveryCodesGenerated: Boolean!

  """Is multi factor enabled - can be toggled off if they want to"""
  multiFactorEnabled: Boolean!

  """Privileged users cannot disable MFA (moderators, staff)"""
  canDisableMultiFactor: Boolean!

  """
  Has TOTP been configured? Recovery codes must be generated before configuring
  """
  multiFactorTotpConfigured: Boolean!
}

type AccountMultiFactorTotp {
  secret: String!

  """
  Always html image compatible. Just set SRC tag to this and it will work!
  """
  imageSrc: String!
}

enum AccountRoleEnum {
  Moderator
  Staff
}

type AccountSecuritySettings {
  """Sessions linked to this account"""
  sessions: [AccountSession!]!

  """Multi factor account settings"""
  multiFactor: AccountMultiFactorSecuritySettings!
}

type AccountSession {
  userAgent: String!
  ip: String!
  created: String!
  id: String!
  current: Boolean!
}

type AccountSettings {
  accountId: String!

  """General account settings for the user"""
  general: AccountGeneralSettings!

  """Security settings for the user"""
  security: AccountSecuritySettings!
  moderator: AccountModeratorSettings
}

type AccountUsername {
  username: String!
}

type Artist {
  id: String!
  avatar: String!
  username: String!
}

type AuditAccount {
  id: String!
  username: String!
}

input AuthenticationInput {
  email: String!
}

type AuthenticationToken {
  sameSession: Boolean!
  redeemed: Boolean!
  session: String!
  email: String!
  accountStatus: AuthenticationTokenAccountStatus
}

type AuthenticationTokenAccountStatus {
  registered: Boolean!
  authenticated: Boolean!
  multiFactor: [MultiFactorTypeEnum!]
}

type Category {
  id: String!
  thumbnail: String!
  title: String!
}

type Character {
  id: String!
  thumbnail: String!
  name: String!
  media: Media!
}

input CharacterRequest {
  name: String!
  media: String!
}

type CharacterRequestType {
  name: String!
  media: String!
}

input ConnectionInput {
  after: String
  before: String
  first: Int
  last: Int
}

type Contributor {
  id: String!
  username: String!
  avatar: String!
}

type Media {
  id: String!
  thumbnail: String!
  title: String!
}

type ModeratePost {
  auditLog: PendingPostAuditLog
  validation: Validation
}

input ModeratePostInput {
  pendingPostId: String!
  rejectionReasonId: String
  notes: String!
}

enum MultiFactorTypeEnum {
  TOTP
}

type Mutation {
  """Initiates an authentication flow for the specified account"""
  authenticate(data: AuthenticationInput): Response!

  """Re-send the authentication email"""
  authenticateEmail: Response!

  """
  Registration for the account. Will only work once authenticate is initiated
  and the cookie is still valid when redeemed (5 minutes)
  """
  register(data: RegisterInput): Response!

  """
  Authenticate with a TOTP code - should be used after a cookie is redeemed
  """
  authenticateTOTP(code: String!): Response!

  """
  Authenticate with a recovery code - should be used after a cookie is redeemed but user does not remember their credentials
  """
  authenticateRecoveryCode(code: String!): Response!

  """
  Unlock Account - account may be locked for any reason. Use this endpoint to
  unlock the currently-logged in account (time must be after the expiration of the unlock)
  """
  unlockAccount: Response!

  """Logout the current account"""
  logout: Response!

  """Add an email to the account, will need to be confirmed"""
  addAccountEmail(email: String!): Response!

  """
  Remove account email - email must belong to account and cannot be the primary email
  """
  removeAccountEmail(email: String!): Response!

  """Modify the current account's username"""
  modifyAccountUsername(username: String!): Response!

  """Revoke a session for this user"""
  revokeAccountSession(id: String!): Response!

  """Make account email primary"""
  makeAccountEmailPrimary(email: String!): Response!

  """
  Generates a new set of recovery codes. The previous set (whatever it was) will be deleted!
  """
  generateAccountMultiFactorRecoveryCodes: [AccountMultiFactorRecoveryCode!]!

  """
  Generate a TOTP key for the current user. Recovery codes must be generated first.
  """
  generateAccountMultiFactorTotp: AccountMultiFactorTotp!

  """
  Enroll into TOTP. Code must be passed from previously-generated TOTP to validate that they have set it up
  """
  enrollAccountMultiFactorTotp(code: String!): Response!

  """
  Toggle Multi-Factor for the user (enable or disable)
  
  Privileged users cannot disable
  
  If it's disabled, all MFA settings will be removed and it will need to be set up again next time
  """
  toggleAccountMultiFactor: Response!

  """Post a new post"""
  post(data: PostInput): PostResponse!

  """Update post"""
  updatePost(id: String!, data: PostInput): Response!

  """
  Moderate a specific pending post
  Pending post must belong to the moderator
  
  If rejecting, must input a rejection reason and additional notes
  """
  moderatePost(data: ModeratePostInput!): ModeratePost!

  """
  Revert an audit log, in case it was done incorrectly
  
  Will delete an infraction if there was one, but the rest of the audit log will generally stay intact
  """
  revertPendingPostAuditLog(data: RevertPostInput!): ModeratePost!

  """
  Toggle moderator status
  
  Will remove or add the moderator from the queue
  
  Current status can be queried from AccountModeratorSettings
  """
  toggleModeratorStatus: Response!
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PendingPost {
  id: String!
  state: PendingPostStateEnum!
  moderator: String!
  contributor: Contributor!
  content: [String!]!
  categories: [Category!]!
  characters: [Character!]!
  mediaRequests: [String!]
  characterRequests: [CharacterRequestType!]
  artistId: String
  artistUsername: String!
  postedAt: Time!
  reassignmentAt: Time!
}

type PendingPostAuditLog {
  id: String!
  postId: String!
  contributor: AuditAccount!
  moderator: AuditAccount!
  infractionId: String
  status: String!
  reason: String!
  notes: String!
  reverted: Boolean!
  canRevert: Boolean!
}

type PendingPostAuditLogConnection {
  edges: [PendingPostAuditLogEdge!]!
  pageInfo: PageInfo!
}

type PendingPostAuditLogEdge {
  node: PendingPostAuditLog!
  cursor: String!
}

input PendingPostAuditLogFilters {
  moderatorId: String
  contributorId: String
  postId: String
  dateRange: [Int!]
}

type PendingPostConnection {
  edges: [PendingPostEdge!]!
  pageInfo: PageInfo!
}

type PendingPostEdge {
  cursor: String!
  node: PendingPost!
}

input PendingPostFilters {
  moderatorId: String
  contributorId: String
  artistId: String
  id: String
}

type PendingPostRejectionReason {
  id: String!
  reason: String!
  infraction: Boolean!
}

enum PendingPostStateEnum {
  Review
  Published
  Discarded
  Rejected
}

input PostInput {
  content: [String!]!
  categories: [String!]!
  characters: [String!]!
  mediaRequests: [String!]
  characterRequests: [CharacterRequest!]
  artistId: String
  artistUsername: String
}

type PostResponse {
  id: String!
  review: Boolean!
  validation: Validation
}

type Query {
  """Get the currently-authenticated account"""
  viewer: Viewer

  """Get current settings for the account"""
  accountSettings: AccountSettings!

  """Confirm account email, so it may be used"""
  confirmAccountEmail(id: String!): Response!

  """Get MFA recovery codes"""
  accountMultiFactorRecoveryCodes: [AccountMultiFactorRecoveryCode!]!

  """Redeem authentication token - token is received from the email"""
  redeemAuthenticationToken(token: String!): AuthenticationToken

  """
  Get the status of the authentication token - whether or not it is redeemed, account status, etc..
  """
  authenticationTokenStatus: AuthenticationToken

  """
  Get Pending Posts, specific to a moderator
  
  Can paginate using Connection Inputs and filter with PendingPostFilters
  
  All filters will work, except moderatorId, which is staff-only (by default, will grab pending post for logged-in user)
  """
  pendingPosts(after: String, before: String, first: Int, last: Int, filter: PendingPostFilters): PendingPostConnection!

  """Get a single pending post by ID"""
  pendingPost(id: String!): PendingPost!
  characters(data: SearchInput!): [Character!]!
  categories(data: SearchInput!): [Category!]!
  artists(data: SearchInput!): [Artist!]!
  media(data: SearchInput!): [Media!]!

  """
  Get pending post for the currently-logged in user
  
  Filters are available, but the moderatorId filter will only work if you are at least a staff role
  
  NOTE: cursor arguments (after, before, first, last, etc...) are not implemented yet
  """
  pendingPostAuditLogs(after: String, before: String, first: Int, last: Int, filter: PendingPostAuditLogFilters): PendingPostAuditLogConnection!

  """
  Get rejection reasons. Only available to moderators + staff
  Used as the input for rejecting a pending post
  """
  rejectionReasons: [PendingPostRejectionReason!]!

  """Infraction history for the currently logged-in account"""
  accountInfractionHistory: [AccountInfractionHistory!]
}

input RegisterInput {
  username: String!
}

type Response {
  ok: Boolean!
  validation: Validation
}

input RevertPostInput {
  auditLogId: String!
}

input SearchInput {
  search: String!
}

scalar Time

type Validation {
  code: String!
}

type Viewer {
  id: ID!
  username: String!
  roles: [AccountRoleEnum!]!
  avatar: String!
  verified: Boolean!
  lock: AccountLock
}
