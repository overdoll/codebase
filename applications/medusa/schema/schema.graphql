type Account implements Node {
  """A URL pointing to the account's public avatar."""
  avatar: Resource

  """Privileged users cannot disable MFA (moderators, staff)"""
  canDisableMultiFactor: Boolean!

  """Posts feed for the clubs that the account currently is a member of."""
  clubMembersPostsFeed(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostConnection!

  """Represents the club memberships that the account has."""
  clubMemberships(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """sorting options for club members."""
    sortBy: ClubMembersSort! = NEWEST
  ): ClubMemberConnection!

  """
  Current count of club memberships. Should be compared against the limit before joining a club.
  """
  clubMembershipsCount: Int!

  """Maximum amount of clubs that you can join as an account."""
  clubMembershipsLimit: Int!

  """Club supporter subscriptions linked to this account."""
  clubSupporterSubscriptions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of account club supporter subscription status."""
    status: [AccountClubSupporterSubscriptionStatus!]
  ): AccountClubSupporterSubscriptionConnection!

  """Represents the clubs that the account has created."""
  clubs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the club."""
    name: String

    """Search by club slugs."""
    slugs: [String!]

    """Sorting options for clubs."""
    sortBy: ClubsSort! = POPULAR
  ): ClubConnection!

  """Current count of the amount of clubs that the account has created."""
  clubsCount: Int!

  """Maximum amount of clubs that you can create."""
  clubsLimit: Int!

  """The curation profile linked to this account."""
  curationProfile: CurationProfile!

  """
  Emails for account (multiple emails per account)
  
  Only queryable if the currently logged-in account belongs to the requested account
  """
  emails(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AccountEmailConnection!

  """Maximum amount of emails that this account can create"""
  emailsLimit: Int!

  """Expired club supporter subscriptions linked to this account."""
  expiredClubSupporterSubscriptions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ExpiredAccountClubSupporterSubscriptionConnection!

  """ID representing the account"""
  id: ID!

  """Whether or not this account is part of the moderation team"""
  isModerator: Boolean!

  """Whether or not this account is secure."""
  isSecure: Boolean!

  """Whether or not this account is a staff member"""
  isStaff: Boolean!

  """
  The language of the account.
  
  Note: this is the language that will be used to determine which emails should be sent where.
  
  You should make sure that the root level "langauge" is the same when the user loads the app, so they get a
  consistent experience. Use "UpdateLanguage" when the languages are mismatched.
  """
  language: Language!

  """The details of the account lock"""
  lock: AccountLock

  """
  Moderator settings and status for this account
  
  Viewable by the currently authenticated account or staff+
  """
  moderatorSettings: ModeratorSettings!

  """Is multi factor enabled - can be toggled off if they want to"""
  multiFactorEnabled: Boolean!

  """
  Has TOTP been configured? Recovery codes must be generated before configuring
  """
  multiFactorTotpConfigured: Boolean!

  """
  Post Audit Logs linked to this account
  
  Viewable by either the currently logged-in account or staff+
  """
  postAuditLogs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """From which date the audit logs should be shown."""
    from: Time!

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    The end date of the audit logs. Optional - if not specified, will search through all-time.
    """
    to: Time
  ): PostAuditLogConnection!

  """Posts queue specific to this account (when moderator)"""
  postModeratorQueue(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostModeratorConnection!

  """Contributions specific to this account"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """
  MFA Recovery codes belonging to this account
  
  Only queryable if the currently logged-in account belongs to the requested account
  """
  recoveryCodes: [AccountMultiFactorRecoveryCode!]!

  """
  Have recovery codes been generated? Required in order to configure TOTP
  """
  recoveryCodesGenerated: Boolean!

  """The ID that the account can be referenced by"""
  reference: String!

  """Saved payment methods linked to this account."""
  savedPaymentMethods(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AccountSavedPaymentMethodConnection!

  """
  Sessions linked to this account
  
  Only queryable if the currently logged-in account belongs to the requested account
  """
  sessions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AccountSessionConnection!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """Total amount of chargeback transactions."""
  transactionsChargebackCount: Int!

  """Total amount of payment transactions."""
  transactionsPaymentCount: Int!

  """Total amount of refund transactions."""
  transactionsRefundCount: Int!

  """Total amount of transactions, excluding voids."""
  transactionsTotalCount: Int!

  """The username of the account."""
  username: String!

  """The next time the username is available to be changed"""
  usernameEditAvailableAt: Time!
}

type AccountActiveClubSupporterSubscription implements IAccountClubSupporterSubscription & Node {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """The last billing date for this subscription."""
  lastBillingDate: Date!

  """The next billing date for this subscription."""
  nextBillingDate: Date!

  """The payment method linked to this subscription."""
  paymentMethod: PaymentMethod!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

type AccountCancelledClubSupporterSubscription implements IAccountClubSupporterSubscription & Node {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The reason this subscription was cancelled, if there is one."""
  cancellationReason: CancellationReason

  """When this subscription was cancelled."""
  cancelledAt: Time!

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """When this subscription will end."""
  endDate: Date!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """The payment method linked to this subscription."""
  paymentMethod: PaymentMethod!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

union AccountClubSupporterSubscription = AccountActiveClubSupporterSubscription | AccountCancelledClubSupporterSubscription | AccountExpiredClubSupporterSubscription

type AccountClubSupporterSubscriptionBillingError {
  """The decline error, parsed in a friendlier way."""
  ccbillDeclineError: CCBillDeclineError

  """The error code from CCBill."""
  ccbillErrorCode: String

  """The error text from CCBill."""
  ccbillErrorText: String

  """When this subscription failed to bill."""
  failedAt: Time!

  """The next date the billing will be retried."""
  nextRetryDate: Date!
}

"""Connection of the account club supporter subscription"""
type AccountClubSupporterSubscriptionConnection {
  edges: [AccountClubSupporterSubscriptionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account club supporter subscriptions"""
type AccountClubSupporterSubscriptionEdge {
  cursor: String!
  node: AccountClubSupporterSubscription!
}

enum AccountClubSupporterSubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

"""Email belonging to a specific account"""
type AccountEmail implements Node {
  """
  The account that this email belongs to
  
  May be null because unconfirmed emails are not yet actually attached to the account
  """
  account: Account

  """The account email"""
  email: String!

  """ID of the account email"""
  id: ID!

  """The current status of the account email"""
  status: AccountEmailStatus!
}

"""Connection of the account email"""
type AccountEmailConnection {
  edges: [AccountEmailEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account email"""
type AccountEmailEdge {
  cursor: String!
  node: AccountEmail!
}

enum AccountEmailStatus {
  CONFIRMED
  PRIMARY
  UNCONFIRMED
}

type AccountExpiredClubSupporterSubscription implements IAccountClubSupporterSubscription & Node {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The reason this subscription was cancelled, if there is one."""
  cancellationReason: CancellationReason

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """When this subscription expired."""
  expiredAt: Time!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

type AccountLock {
  expires: Time!
}

"""The multi-factor recovery code belonging to the account"""
type AccountMultiFactorRecoveryCode {
  """The multi factor recovery code"""
  code: String!
}

type AccountSavedPaymentMethod {
  """The account linked to this saved payment method."""
  account: Account!

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """An ID to uniquely identify this payment method."""
  id: ID!

  """The payment method."""
  paymentMethod: PaymentMethod!

  """When this payment method was last updated."""
  updatedAt: Time!
}

"""Connection of the account saved payment method"""
type AccountSavedPaymentMethodConnection {
  edges: [AccountSavedPaymentMethodEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account saved payment method"""
type AccountSavedPaymentMethodEdge {
  cursor: String!
  node: AccountSavedPaymentMethod!
}

"""Session belonging to a specific account"""
type AccountSession implements Node {
  """When the session was created"""
  created: Time!

  """
  If the session belongs to the currently authenticated account. This means that the session cannot be revoked (or else we get weird stuff)
  """
  current: Boolean!

  """The originating user agent device"""
  device: String!

  """ID of the session"""
  id: ID!

  """The original IP"""
  ip: String!

  """When the session was last seen (last API call)"""
  lastSeen: Time!

  """Where the session was originally created"""
  location: Location!
}

"""Edge of the account session"""
type AccountSessionConnection {
  edges: [AccountSessionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account session"""
type AccountSessionEdge {
  cursor: String!
  node: AccountSession!
}

"""Properties by which accounts connections can be sorted."""
enum AccountsSort {
  """Accounts by newest first"""
  NEW
}

"""
A transaction item.

All transactions start off in the "PAYMENT" type.

Once a transaction is refunded once, it turns into a REFUND transaction + an event is added.

If a transaction is charged back, it turns into a CHARGEBACK transaction + an event is added.

If a transaction is voided, it turns into a VOID transaction.
"""
type AccountTransaction implements Node {
  """
  The amount voided.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  amount: Int!

  """When the billing occurred."""
  billedAtDate: Date!

  """A ccbill transaction, if this transaction originated from ccbill."""
  ccbillTransaction: CCBillTransaction

  """
  The subscription linked to this transaction, if it's a club supporter subscription.
  """
  clubSupporterSubscription: AccountClubSupporterSubscription

  """The currency voided in."""
  currency: Currency!

  """
  The events for this transaction.
  
  If the transaction was refunded, an event will show up with the refund amount.
  
  If the transaction was charged back, an event will show up with the chargeback amount.
  """
  events: [AccountTransactionEvent!]!

  """An ID to uniquely identify this transaction history."""
  id: ID!

  """The next billing date for this transaction, if its a subscription."""
  nextBillingDate: Date

  """The payment method linked to this transaction."""
  paymentMethod: PaymentMethod!

  """A reference, used to look up this transaction."""
  reference: String!

  """When this transaction occurred."""
  timestamp: Time!

  """The type of account transaction history, or what it belongs to."""
  type: AccountTransactionType!
}

"""Connection of the account transaction."""
type AccountTransactionConnection {
  edges: [AccountTransactionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the the account transaction."""
type AccountTransactionEdge {
  cursor: String!
  node: AccountTransaction!
}

type AccountTransactionEvent {
  """The amount."""
  amount: Int!

  """The currency."""
  currency: Currency!

  """An ID to uniquely identify account transaction."""
  id: ID!

  """The reason for this event."""
  reason: String!

  """When this event occurred."""
  timestamp: Time!
}

enum AccountTransactionType {
  CHARGEBACK
  PAYMENT
  REFUND
  VOID
}

"""Add an email to the account"""
input AddAccountEmailInput {
  """The email that should be added to this account"""
  email: String!
}

"""Email to add the account"""
type AddAccountEmailPayload {
  """The account email that was added to"""
  accountEmail: AccountEmail

  """Any validation errors from the backend"""
  validation: AddAccountEmailValidation
}

"""Validation message for adding account email"""
enum AddAccountEmailValidation {
  INVALID_EMAIL
}

"""Add alias slug."""
input AddClubSlugAliasInput {
  """The club to update"""
  id: ID!

  """
  The chosen slug for the club.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!
}

"""Payload for a new alt slug"""
type AddClubSlugAliasPayload {
  """The club after update"""
  club: Club

  """Validation for adding a new club"""
  validation: AddClubSlugAliasValidation
}

"""Validation for adding a new slug to a club"""
enum AddClubSlugAliasValidation {
  SLUG_TAKEN
}

"""Add moderator to posts queue."""
input AddModeratorToPostQueueInput {
  """The moderator account to take the action on"""
  accountId: ID!
}

"""Remove moderator from posts queue."""
type AddModeratorToPostQueuePayload {
  """The account that was updated"""
  account: Account
}

"""Add post content."""
input AddPostContentInput {
  """Image IDs for the content"""
  content: [String!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type AddPostContentPayload {
  """The post after the update"""
  post: Post
}

"""Approve the pending post input"""
input ApprovePostInput {
  """Pending post to take action against"""
  postId: ID!
}

"""Approve the pending post payload"""
type ApprovePostPayload {
  """The resulting post"""
  post: Post
}

"""Archive post."""
input ArchivePostInput {
  """The post to archive"""
  id: ID!
}

"""Payload for archiving a post"""
type ArchivePostPayload {
  """The archived post."""
  post: Post
}

"""Input to assign account to a moderator role"""
input AssignAccountModeratorRole {
  """The account ID that the role needs to be assigned to"""
  accountId: ID!
}

"""Assigned account"""
type AssignAccountModeratorRolePayload {
  """The account that the role was assigned to"""
  account: Account
}

"""Input to assign account to a staff role"""
input AssignAccountStaffRole {
  """The account ID that the role needs to be assigned to"""
  accountId: ID!
}

"""Assigned account"""
type AssignAccountStaffRolePayload {
  """The account that the role was assigned to"""
  account: Account
}

type Audience implements Node {
  """An ID pointing to this audience."""
  id: ID!

  """Posts belonging to this audience"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """A url-friendly ID. Should be used when searching."""
  slug: String!

  """If this audience is standard or not."""
  standard: Boolean!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """A title for this audience."""
  title: String!

  """All translations for this title."""
  titleTranslations: [Translation!]!

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type AudienceConnection {
  edges: [AudienceEdge!]!
  pageInfo: PageInfo!
}

type AudienceCurationProfile {
  """Audiences selected for this section."""
  audiences: [Audience!]!

  """Whether or not the audience section was completed."""
  completed: Boolean!

  """Whether or not the audience section was skipped."""
  skipped: Boolean!
}

type AudienceEdge {
  cursor: String!
  node: Audience!
}

"""Properties by which audience connections can be sorted."""
enum AudiencesSort {
  """Audience by newest first"""
  NEW

  """Audience by most posts"""
  POPULAR

  """Audience by top likes"""
  TOP
}

"""Authentication token. Used for logging in."""
type AuthenticationToken {
  """Once the token is verified, you can see the status of the account."""
  accountStatus: AuthenticationTokenAccountStatus

  """Unique ID of the token"""
  id: ID!

  """The location where this token was created at."""
  location: Location!

  """
  When the token is viewed with the correct ID, whether or not the devices match (you cannot use the token unless the device is the same).
  """
  sameDevice: Boolean!

  """
  Whether or not this token is "secure"
  Secure means that the token has been viewed from the same network as originally created
  if it wasn't viewed in the same network, the interface should take care and double-check with
  the user that they want to verify the token.
  """
  secure: Boolean!

  """Token belong to this authentication token"""
  token: String!

  """The userAgent this token was created from."""
  userAgent: String!

  """
  Whether or not the token is verified (required in order to see account status, and to use it for completing the auth flow).
  """
  verified: Boolean!
}

type AuthenticationTokenAccountStatus {
  """If multi-factor is enabled for this account"""
  multiFactor: MultiFactor

  """
  When verified, whether or not there is an account belonging to this token.
  """
  registered: Boolean!
}

"""Localization formatted in BCP47."""
scalar BCP47

"""Become club supporter with saved payment method."""
input BecomeClubSupporterWithAccountSavedPaymentMethodInput {
  """The chosen club ID."""
  clubId: ID!

  """The chosen currency."""
  currency: Currency!

  """The chosen saved payment method."""
  savedPaymentMethodId: ID!
}

"""Payload for a new club supporter"""
type BecomeClubSupporterWithAccountSavedPaymentMethodPayload {
  """
  CCBill Transaction Token, if this was a ccbill transaction. Used to query more details about this transaction.
  """
  ccbillTransactionToken: String
}

"""Represents a billing address."""
type BillingAddress {
  addressLine1: String!
  city: String!
  country: String!
  postalCode: String!
  state: String!
}

"""Represents a billing contact."""
type BillingContact {
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String!
}

"""Cancel account club supporter subscription input."""
input CancelAccountClubSupporterSubscriptionInput {
  """The cancellation reason for this subscription."""
  cancellationReasonId: ID!

  """The chosen club supporter subscription id."""
  clubSupporterSubscriptionId: ID!
}

"""Payload for cancelling the account club supporter."""
type CancelAccountClubSupporterSubscriptionPayload {
  """The new subscription."""
  clubSupporterSubscription: AccountClubSupporterSubscription
}

"""Cancellation reason."""
type CancellationReason implements Node {
  """If this reason is deprecated."""
  deprecated: Boolean!

  """ID of the reason."""
  id: ID!

  """Reference of the reason. Should be used for single lookups."""
  reference: String!

  """The title for this reason."""
  title: String!

  """All translations for this title."""
  titleTranslations: [Translation!]!
}

"""Connection of the reason"""
type CancellationReasonConnection {
  edges: [CancellationReasonEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the reason"""
type CancellationReasonEdge {
  cursor: String!
  node: CancellationReason!
}

"""Represents a card."""
type Card {
  """The expiration date."""
  expiration: String!

  """Last 4 digits of the card."""
  last4: String!

  """The type of card."""
  type: CardType!
}

enum CardType {
  AMEX
  DISCOVER
  JCB
  MASTERCARD
  OTHER
  VISA
}

"""Properties by which categories connections can be sorted."""
enum CategoriesSort {
  """Categories by newest first"""
  NEW

  """Categories by most posts"""
  POPULAR

  """Categories by top likes"""
  TOP
}

type Category implements Node {
  """An ID pointing to this category."""
  id: ID!

  """Posts belonging to this category"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """A title for this category."""
  title: String!

  """All translations for this title."""
  titleTranslations: [Translation!]!

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type CategoryConnection {
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
}

type CategoryCurationProfile {
  """Categories selected for this section."""
  categories: [Category!]!

  """Whether or not the category section was completed."""
  completed: Boolean!

  """Whether or not the category section was skipped."""
  skipped: Boolean!
}

type CategoryEdge {
  cursor: String!
  node: Category!
}

enum CCBillDeclineError {
  CARD_EXPIRED
  GENERAL_SYSTEM_ERROR
  INSUFFICIENT_FUNDS
  RATE_LIMIT_ERROR
  TRANSACTION_APPROVAL_REQUIRED
  TRANSACTION_DECLINED
  TRANSACTION_DENIED_OR_REFUSED_BY_BANK
}

"""
The ccbill subscription details.

When this object is present, this means that it can only be updated through CCBill support. https://support.ccbill.com/

For example: active subscriptions' payment methods can only be updated through support, or any saved payment methods.
"""
type CCBillSubscription {
  """The identifier for this subscription."""
  ccbillSubscriptionId: String!

  """The email belonging to this subscription."""
  email: String!

  """A link to modify the subscription."""
  link: URI!

  """The payment method belonging to this subscription."""
  paymentMethod: String!
}

type CCBillSubscriptionDetails {
  """The account linked to this ccbill subscription."""
  account: Account!
  accountingCurrency: Currency!

  """Accounting details."""
  accountingInitialPrice: Int!
  accountingRecurringPrice: Int!
  billedCurrency: Currency!

  """Billed details."""
  billedInitialPrice: Int!
  billedRecurringPrice: Int!

  """If this subscription was cancelled, the date it occurred."""
  cancelDate: Time

  """The amount of chargebacks issued."""
  chargebacksIssued: Int!

  """The club linked to this ccbill subscription, if there is one."""
  club: Club

  """If this subscription was cancelled, the expiration date."""
  expirationDate: Time

  """The ID of the subscription."""
  id: ID!

  """Whether or not this is recurring, or a one-time charge."""
  isRecurring: Boolean!

  """Payment method linked to this CCBill subscription."""
  paymentMethod: PaymentMethod!

  """The amount of refunds issued."""
  refundsIssued: Int!

  """The signup date."""
  signupDate: Time!

  """The status of the CCBill subscription."""
  status: CCBillSubscriptionStatus!
  subscriptionCurrency: Currency!

  """Subscription details."""
  subscriptionInitialPrice: Int!
  subscriptionRecurringPrice: Int!

  """The amount of rebills that occurred."""
  timesRebilled: Int!

  """When this subscription was updated last."""
  updatedAt: Time!

  """The amount of voids issued."""
  voidsIssued: Int!
}

enum CCBillSubscriptionStatus {
  """An active subscription that was cancelled, or a one-time charge."""
  ACTIVE_AND_CANCELLED

  """An active subscription that is not cancelled."""
  ACTIVE_AND_NOT_CANCELLED

  """An inactive subscription, i.e. expired."""
  INACTIVE
}

"""
Represents a CCBill transaction, which may or may not contain these fields.
"""
type CCBillTransaction {
  ccbillSubscriptionId: String!
  ccbillTransactionId: String
}

type CCBillTransactionDetails {
  """Whether or not the transaction was approved."""
  approved: Boolean!

  """The decline code from CCBill."""
  declineCode: String

  """The error from CCBill, if the transaction was not approved."""
  declineError: CCBillDeclineError

  """The decline text from CCBill."""
  declineText: String

  """An ID uniquely identifying this transaction."""
  id: ID!

  """
  If this transaction was approved, poll this field to until this is not null anymore.
  
  This signifies that the transaction has processed successfully (on our end),
  
  and the supporter benefits are now available.
  """
  linkedAccountClubSupporterSubscription: AccountClubSupporterSubscription
}

type Character implements Node {
  """An ID pointing to this character."""
  id: ID!

  """A name for this character."""
  name: String!

  """All translations for this name."""
  nameTranslations: [Translation!]!

  """Posts belonging to this character"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """The series linked to this character."""
  series: Series!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type CharacterConnection {
  edges: [CharacterEdge!]!
  pageInfo: PageInfo!
}

type CharacterEdge {
  cursor: String!
  node: Character!
}

"""Properties by which character connections can be sorted."""
enum CharactersSort {
  """Characters by newest first"""
  NEW

  """Characters by most posts"""
  POPULAR

  """Characters by top likes"""
  TOP
}

type Club implements Node {
  """An ID pointing to this club."""
  id: ID!

  """
  Infraction history for this club
  
  Viewable by the currently authenticated account or staff+
  """
  infractionHistory(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClubInfractionHistoryConnection!

  """Club members."""
  members(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """sorting options for club members."""
    sortBy: ClubMembersSort! = NEWEST
  ): ClubMemberConnection!

  """The total amount of members in this club."""
  membersCount: Int!

  """A name for this club."""
  name: String!

  """The account that owns this club."""
  owner: Account!

  """Posts belonging to this club"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """An internal reference, uniquely identifying the club."""
  reference: String!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """
  An alias list of slugs. These are valid, as in, you can find the club using the slug. However, it should always be replaced by the default slug.
  """
  slugAliases: [ClubSlugAlias!]!

  """Maximum amount of slug aliases that can be created for this club."""
  slugAliasesLimit: Int!

  """A supporter subscription price for this club."""
  supporterSubscriptionPrice: LocalizedPricingPoint!

  """Whether or not this club is suspended."""
  suspension: ClubSuspension

  """A URL pointing to the object's thumbnail."""
  thumbnail(size: Int): Resource

  """Whether or not the viewer is the owner of the club."""
  viewerIsOwner: Boolean!

  """Whether or not the viewer is a member of this club."""
  viewerMember: ClubMember
}

type ClubConnection {
  edges: [ClubEdge!]!
  pageInfo: PageInfo!
}

type ClubEdge {
  cursor: String!
  node: Club!
}

"""Infraction history belonging to a club"""
type ClubInfractionHistory implements Node {
  """The club belonging to this history object."""
  club: Club!

  """
  When this infraction expires (no longer considered when issuing future infractions).
  """
  expiresAt: Time!

  """ID of the infraction history"""
  id: ID!

  """When this infraction was issued."""
  issuedAt: Time!

  """The account that issued this infraction."""
  issuerAccount: Account!

  """The rule cited for this infraction."""
  rule: Rule!

  """The source for this infraction."""
  source: ClubInfractionHistorySource!
}

"""Connection of the infraction history"""
type ClubInfractionHistoryConnection {
  edges: [ClubInfractionHistoryEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the infraction history"""
type ClubInfractionHistoryEdge {
  cursor: String!
  node: ClubInfractionHistory!
}

enum ClubInfractionHistorySource {
  MANUAL
  POST_MANUAL_REMOVAL
  POST_MODERATION_REJECTION
}

type ClubMember implements Node {
  """The account that belongs to this membership."""
  account: Account!

  """The club that this membership belongs to."""
  club: Club!

  """An ID pointing to this club member."""
  id: ID!

  """Whether or not this member is a supporter."""
  isSupporter: Boolean!

  """When the membership was created (when the account originally joined)."""
  joinedAt: Time!

  """If is a supporter, when they became a supporter."""
  supporterSince: Time
}

type ClubMemberConnection {
  edges: [ClubMemberEdge!]!
  pageInfo: PageInfo!
}

type ClubMemberEdge {
  cursor: String!
  node: ClubMember!
}

"""Properties by which club member connections can be sorted."""
enum ClubMembersSort {
  """By oldest members"""
  NEWEST
}

"""The club slug alias"""
type ClubSlugAlias {
  """The slug alias"""
  slug: String!
}

"""Properties by which club connections can be sorted."""
enum ClubsSort {
  """Clubs by popularity"""
  POPULAR
}

type ClubSuspension {
  """When the suspension expires. Can call UnSuspendClub when time = now."""
  expires: Time!
}

"""Input for confirming the account email"""
input ConfirmAccountEmailInput {
  """The ID that is sent for confirmation"""
  id: String!

  """The secret for email confirmation."""
  secret: String!
}

"""Payload for confirming the account email"""
type ConfirmAccountEmailPayload {
  """The account email that was confirmed"""
  accountEmail: AccountEmail

  """Validation for confirming account email"""
  validation: ConfirmAccountEmailValidation
}

"""Validation for confirming account email"""
enum ConfirmAccountEmailValidation {
  EMAIL_TAKEN
  TOKEN_EXPIRED
}

"""Payload for creating an account with authentication token"""
input CreateAccountWithAuthenticationTokenInput {
  """The original token"""
  token: String!

  """
  The username to create the account with.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  username: String!
}

"""Payload for creating an account"""
type CreateAccountWithAuthenticationTokenPayload {
  """The account that was created"""
  account: Account

  """A token is revoked once an account is created, this represents it"""
  revokedAuthenticationTokenId: ID!

  """Validation for creating an account"""
  validation: CreateAccountWithAuthenticationTokenValidation
}

"""Validation for creating an account with an authentication token"""
enum CreateAccountWithAuthenticationTokenValidation {
  EMAIL_TAKEN
  TOKEN_INVALID
  USERNAME_TAKEN
}

"""Create a new audience."""
input CreateAudienceInput {
  """
  The chosen slug for the audience.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!

  """If the audience is standard or not."""
  standard: Boolean!

  """
  The chosen title for the audience.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for a new audience"""
type CreateAudiencePayload {
  """The audience after creation"""
  audience: Audience

  """Validation for creating a new audience"""
  validation: CreateAudienceValidation
}

"""Validation for creating a new audience"""
enum CreateAudienceValidation {
  SLUG_TAKEN
}

"""Create a new cancellation reason input."""
input CreateCancellationReasonInput {
  """The title."""
  title: String!
}

"""Updated cancellation reason."""
type CreateCancellationReasonPayload {
  """The updated cancellation reason."""
  cancellationReason: CancellationReason
}

"""Create a new category."""
input CreateCategoryInput {
  """
  The chosen slug for the category.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!

  """
  The chosen title for the category.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for a new category"""
type CreateCategoryPayload {
  """The category after creation"""
  category: Category

  """Validation for creating a new category"""
  validation: CreateCategoryValidation
}

"""Validation for creating a new category"""
enum CreateCategoryValidation {
  SLUG_TAKEN
}

"""Create a new character."""
input CreateCharacterInput {
  """
  The chosen name for the character.
  
  Validation: Max 25 characters.
  """
  name: String!

  """The chosen series for the character."""
  seriesId: ID!

  """
  The chosen slug for the character.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!
}

"""Payload for a new character"""
type CreateCharacterPayload {
  """The character after creation"""
  character: Character

  """Validation for creating a new character"""
  validation: CreateCharacterValidation
}

"""Validation for creating a new character"""
enum CreateCharacterValidation {
  SLUG_TAKEN
}

"""Create club."""
input CreateClubInput {
  """
  The chosen name for the club.
  
  Validation: Max 25 characters.
  """
  name: String!

  """
  The chosen slug for the club.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!
}

"""Payload for a new club"""
type CreateClubPayload {
  """The club after creation"""
  club: Club

  """Validation for creating a new club"""
  validation: CreateClubValidation
}

"""Validation for creating a new club"""
enum CreateClubValidation {
  SLUG_TAKEN
}

"""Create a new post. A club ID is required."""
input CreatePostInput {
  """The club ID that this post will belong to"""
  clubId: ID!
}

"""Payload for a created pending post"""
type CreatePostPayload {
  """The pending post after the creation"""
  post: Post
}

"""Create a new rule input."""
input CreateRuleInput {
  """
  The description.
  
  Validation: Max 25 characters. Markdown allowed.
  """
  description: String!

  """If breaking this rule would cause an infraction."""
  infraction: Boolean!

  """
  The title.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Updated rule."""
type CreateRulePayload {
  """The updated rule."""
  rule: Rule
}

"""Create a new series."""
input CreateSeriesInput {
  """
  The chosen slug for the series.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!

  """
  The chosen title for the series.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for a new series"""
type CreateSeriesPayload {
  """The series after creation"""
  series: Series

  """Validation for creating a new series"""
  validation: CreateSeriesValidation
}

"""Validation for creating a new series"""
enum CreateSeriesValidation {
  SLUG_TAKEN
}

type CurationProfile {
  """The audience profile."""
  audience: AudienceCurationProfile!

  """The category profile."""
  category: CategoryCurationProfile!

  """If the whole profile was completed or not."""
  completed: Boolean!

  """The date of birth profile."""
  dateOfBirth: DateOfBirthCurationProfile!

  """An ID uniquely identifying this profile."""
  id: ID!
}

enum Currency {
  AUD
  CAD
  EUR
  GBP
  JPY
  USD
}

scalar Date

type DateOfBirthCurationProfile {
  """Whether or not the date of birth section was completed."""
  completed: Boolean!

  """The date of birth set."""
  dateOfBirth: Time

  """Whether or not the date of birth section was skipped."""
  skipped: Boolean!
}

"""Input for removing an email from an account"""
input DeleteAccountEmailInput {
  """The email that should be removed"""
  accountEmailId: ID!
}

"""Email to add the account"""
type DeleteAccountEmailPayload {
  """The ID of the account email that was removed"""
  accountEmailId: ID!
}

"""Delete an account saved payment method input."""
input DeleteAccountSavedPaymentMethodInput {
  """The chosen saved payment method id."""
  savedPaymentMethodId: ID!
}

"""Payload for deleting an account saved payment method."""
type DeleteAccountSavedPaymentMethodPayload {
  """The deleted saved payment method."""
  deletedAccountSavedPaymentMethodId: ID!
}

"""Delete post."""
input DeletePostInput {
  """The post to delete"""
  id: ID!
}

"""Payload for deleting a post"""
type DeletePostPayload {
  """The deleted post."""
  postId: ID
}

"""Payload for disabling account multi factor"""
type DisableAccountMultiFactorPayload {
  """TOTP that was removed from this account, if it was removed"""
  accountMultiFactorTotpEnabled: Boolean
}

"""Input for enrolling the account into TOTP"""
input EnrollAccountMultiFactorTotpInput {
  """The code that the TOTP expects"""
  code: String!

  """The TOTP ID, sent initially"""
  id: String!
}

"""Payload of the enrolled totp payload"""
type EnrollAccountMultiFactorTotpPayload {
  """TOTP that belongs to this account now"""
  accountMultiFactorTotpEnabled: Boolean

  """Validation for enrolling TOTP"""
  validation: EnrollAccountMultiFactorTotpValidation
}

"""Validation for enrolling in TOTP"""
enum EnrollAccountMultiFactorTotpValidation {
  INVALID_CODE
}

"""An expired account club supporter subscription."""
type ExpiredAccountClubSupporterSubscription {
  """The account linked to this subscription."""
  account: Account!

  """When this subscription was originally cancelled."""
  cancelledAt: Time!

  """The club linked to this subscription."""
  club: Club!

  """Wen this subscription expired."""
  expiredAt: Time!

  """An ID to uniquely identify this expired subscription."""
  id: ID!

  """
  When the account first became a supporter. Note that when subscribing next time, this date will be kept, but subtracted by the amount of days they were not a supporter, and normalized to the current date.
  """
  supporterSince: Time!
}

"""Connection of the expired account club supporter subscription"""
type ExpiredAccountClubSupporterSubscriptionConnection {
  edges: [ExpiredAccountClubSupporterSubscriptionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the expired account club supporter subscriptions"""
type ExpiredAccountClubSupporterSubscriptionEdge {
  cursor: String!
  node: ExpiredAccountClubSupporterSubscription!
}

"""Extend account club supporter subscription input."""
input ExtendAccountClubSupporterSubscriptionInput {
  """The chosen club supporter subscription id."""
  clubSupporterSubscriptionId: ID!

  """The amount of days to extend it for."""
  days: Int!
}

"""Payload for extending the account club supporter."""
type ExtendAccountClubSupporterSubscriptionPayload {
  """The new subscription."""
  clubSupporterSubscription: AccountClubSupporterSubscription
}

"""Payload of the created account recovery codes"""
type GenerateAccountMultiFactorRecoveryCodesPayload {
  """The recovery codes that were created"""
  accountMultiFactorRecoveryCodes: [AccountMultiFactorRecoveryCode!]!
}

"""Payload of the generated TOTP token"""
type GenerateAccountMultiFactorTotpPayload {
  """TOTP pair that was generated"""
  multiFactorTotp: MultiFactorTotp
}

"""Generate ccbill club supporter payment link."""
input GenerateCCBillClubSupporterPaymentLinkInput {
  """The chosen club ID."""
  clubId: ID!

  """The chosen currency."""
  currency: Currency!

  """Whether or not we want to save the payment details for later."""
  savePaymentDetailsForLater: Boolean!
}

"""Payload for a new ccbill payment link"""
type GenerateCCBillClubSupporterPaymentLinkPayload {
  """The payment link to use."""
  paymentLink: URI
}

"""Generate club supporter receipt input."""
input GenerateClubSupporterPaymentReceiptFromAccountTransactionInput {
  """The id of the transaction."""
  transactionId: ID!
}

"""Payload for generating the receipt."""
type GenerateClubSupporterPaymentReceiptFromAccountTransactionPayload {
  """The link to the receipt."""
  link: URI
}

"""Generate club supporter receipt input."""
input GenerateClubSupporterRefundReceiptFromAccountTransactionInput {
  """The id of the transaction event, since we can have multiple refunds."""
  transactionEventId: ID!

  """The id of the transaction."""
  transactionId: ID!
}

"""Payload for generating the receipt."""
type GenerateClubSupporterRefundReceiptFromAccountTransactionPayload {
  """The link to the receipt."""
  link: URI
}

"""Generate a refund amount."""
input GenerateRefundAmountForAccountTransactionInput {
  """The id of the transaction."""
  accountTransactionId: ID!
}

"""Payload for generating the receipt."""
type GenerateRefundAmountForAccountTransactionPayload {
  """The refund amount."""
  refundAmount: RefundAmount
}

"""
Payload for granting access to an account using the token and the recovery code
"""
input GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeInput {
  """Recovery code"""
  recoveryCode: String!

  """The original token"""
  token: String!
}

"""
Payload for granting access to an account using the authentication token and Recovery Code
"""
type GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodePayload {
  """The account that granted access to"""
  account: Account

  """
  A token is revoked once the account access is granted, this represents it
  """
  revokedAuthenticationTokenId: ID!

  """Validation options"""
  validation: GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeValidation
}

"""Validation for granting account access with multi factor"""
enum GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeValidation {
  RECOVERY_CODE_INVALID
  TOKEN_INVALID
}

"""
Payload for granting access to an account using the token and the totp code
"""
input GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpInput {
  """TOTP code"""
  code: String!

  """The original token"""
  token: String!
}

"""
Payload for granting access to an account using the authentication token and TOTP code
"""
type GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpPayload {
  """The account that granted access to"""
  account: Account

  """
  A token is revoked once the account access is granted, this represents it
  """
  revokedAuthenticationTokenId: ID!

  """Validation options"""
  validation: GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpValidation
}

"""Validation for granting account access with multi factor"""
enum GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpValidation {
  CODE_INVALID
  TOKEN_INVALID
}

"""
Payload for granting account access with the token. Will fail if account has multi-factor auth enabled.
"""
input GrantAccountAccessWithAuthenticationTokenInput {
  """The original token"""
  token: String!
}

type GrantAccountAccessWithAuthenticationTokenPayload {
  """The account that granted access to"""
  account: Account

  """
  A token is revoked once the account access is granted, this represents it
  """
  revokedAuthenticationTokenId: ID!

  """Validation options"""
  validation: GrantAccountAccessWithAuthenticationTokenValidation
}

enum GrantAccountAccessWithAuthenticationTokenValidation {
  TOKEN_INVALID
}

"""Input for granting an authentication token"""
input GrantAuthenticationTokenInput {
  """The email that the token will be granted for"""
  email: String!
}

"""Payload for starting an authentication"""
type GrantAuthenticationTokenPayload {
  """The authentication token after starting"""
  authenticationToken: AuthenticationToken

  """Validation for granting an authentication token"""
  validation: GrantAuthenticationTokenValidation
}

"""Validation for granting an authentication token"""
enum GrantAuthenticationTokenValidation {
  INVALID_EMAIL
}

interface IAccountClubSupporterSubscription {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

"""Issue a club infraction."""
input IssueClubInfractionInput {
  """The club to issue the infraction to."""
  clubId: ID!

  """
  Pass a custom end time. If none is passed, will use sliding scale based on previous infractions.
  """
  customEndTime: Time

  """The rule to cite."""
  ruleId: ID!
}

"""Issue a new club infraction payload."""
type IssueClubInfractionPayload {
  """The new club infraction history item."""
  clubInfractionHistory: ClubInfractionHistory
}

"""Join a club input."""
input JoinClubInput {
  """The chosen club ID."""
  clubId: ID!
}

"""Payload for a new club member"""
type JoinClubPayload {
  """The membership after creation"""
  clubMember: ClubMember
}

type Language {
  """BCP47 locale"""
  locale: BCP47!

  """Fully qualified name"""
  name: String!
}

"""Leave a club."""
input LeaveClubInput {
  """The chosen club ID."""
  clubId: ID!
}

"""Payload for leaving a club"""
type LeaveClubPayload {
  """The club membership that was removed"""
  clubMemberId: ID!
}

"""Like a post."""
input LikePostInput {
  """The post ID that you want to like"""
  id: ID!
}

"""Payload for the liked post"""
type LikePostPayload {
  """The new PostLike entry."""
  postLike: PostLike
}

"""Type describing a localized pricing point."""
type LocalizedPricingPoint {
  """Price for your current location + currency."""
  localizedPrice: Price!

  """All other prices in different currencies."""
  prices: [Price!]!
}

"""Represents a physical location."""
type Location {
  """City"""
  city: String!

  """Country"""
  country: String!

  """Latitude"""
  latitude: Float!

  """Longitude"""
  longitude: Float!

  """Postal Code"""
  postalCode: String!

  """Subdivision"""
  subdivision: String!
}

"""Input for locking an account."""
input LockAccountInput {
  """The account to lock."""
  accountID: ID!

  """When the lock should end."""
  endTime: Time!
}

"""Payload for the locked account"""
type LockAccountPayload {
  """Account that was locked"""
  account: Account
}

"""General moderator settings."""
type ModeratorSettings {
  """If this moderator is in queue."""
  isInModeratorQueue: Boolean!

  """
  The last time this moderator was selected for a post. Null if moderator not in queue
  """
  lastSelected: Time
}

"""Types of multi factor enabled for this account"""
type MultiFactor {
  totp: Boolean!
}

"""TOTP secret + image combination"""
type MultiFactorTotp {
  """The TOTP ID. Should be sent back when creating the TOTP"""
  id: String!

  """
  Always html image compatible. Just set SRC tag to this and it will work!
  """
  imageSrc: String!

  """The TOTP secret"""
  secret: String!
}

type Mutation {
  """Add an email to the account, will need to be confirmed"""
  addAccountEmail(input: AddAccountEmailInput!): AddAccountEmailPayload

  """Add an alternative slug to the club"""
  addClubSlugAlias(input: AddClubSlugAliasInput!): AddClubSlugAliasPayload

  """
  Add moderator to posts queue
  
  Moderator+ only
  """
  addModeratorToPostQueue(input: AddModeratorToPostQueueInput!): AddModeratorToPostQueuePayload

  """Update a post in draft status - add content"""
  addPostContent(input: AddPostContentInput!): AddPostContentPayload

  """
  Approve a specific post.
  
  Moderator+ only
  """
  approvePost(input: ApprovePostInput!): ApprovePostPayload

  """Archive a post, removing it from public visibility."""
  archivePost(input: ArchivePostInput!): ArchivePostPayload

  """Assign a moderator role to the account"""
  assignAccountModeratorRole(input: AssignAccountModeratorRole!): AssignAccountModeratorRolePayload

  """Assign a staff role to the account"""
  assignAccountStaffRole(input: AssignAccountStaffRole!): AssignAccountStaffRolePayload

  """Become a club supporter using a saved payment method"""
  becomeClubSupporterWithAccountSavedPaymentMethod(input: BecomeClubSupporterWithAccountSavedPaymentMethodInput!): BecomeClubSupporterWithAccountSavedPaymentMethodPayload

  """Cancel a club supporter subscription"""
  cancelAccountClubSupporterSubscription(input: CancelAccountClubSupporterSubscriptionInput!): CancelAccountClubSupporterSubscriptionPayload

  """Confirm account email, so it may be used"""
  confirmAccountEmail(input: ConfirmAccountEmailInput!): ConfirmAccountEmailPayload

  """Create an account using the current authentication token"""
  createAccountWithAuthenticationToken(input: CreateAccountWithAuthenticationTokenInput!): CreateAccountWithAuthenticationTokenPayload

  """Create a new audience"""
  createAudience(input: CreateAudienceInput!): CreateAudiencePayload

  """Create a new reason."""
  createCancellationReason(input: CreateCancellationReasonInput!): CreateCancellationReasonPayload

  """Create a new category"""
  createCategory(input: CreateCategoryInput!): CreateCategoryPayload

  """Create a new character"""
  createCharacter(input: CreateCharacterInput!): CreateCharacterPayload

  """Create a new club"""
  createClub(input: CreateClubInput!): CreateClubPayload

  """Create a new post"""
  createPost(input: CreatePostInput!): CreatePostPayload

  """Create a new rule."""
  createRule(input: CreateRuleInput!): CreateRulePayload

  """Create a new series"""
  createSeries(input: CreateSeriesInput!): CreateSeriesPayload

  """
  Delete account email - email must belong to account and cannot be the primary email
  """
  deleteAccountEmail(input: DeleteAccountEmailInput!): DeleteAccountEmailPayload

  """Delete an account saved payment method"""
  deleteAccountSavedPaymentMethod(input: DeleteAccountSavedPaymentMethodInput!): DeleteAccountSavedPaymentMethodPayload

  """
  Delete a post. Can only be deleted if the post is in Draft, Archived, Removed, Discarded or Rejected state.
  """
  deletePost(input: DeletePostInput!): DeletePostPayload

  """
  Disable account multi factor
  
  Will delete all multi factor settings (if TOTP is set up, etc...)
  
  Priv. users cannot disable multi factor
  """
  disableAccountMultiFactor: DisableAccountMultiFactorPayload

  """
  Enroll into TOTP.
  
  Must have called "generateAccountMultiFactorTOTP" first before enrolling, since this will
  generate a valid secret
  """
  enrollAccountMultiFactorTotp(input: EnrollAccountMultiFactorTotpInput!): EnrollAccountMultiFactorTotpPayload

  """
  Extend an account club supporter subscription for an X amount of days, so basically delay their billing date for x days.
  
  Staff+ only.
  """
  extendAccountClubSupporterSubscription(input: ExtendAccountClubSupporterSubscriptionInput!): ExtendAccountClubSupporterSubscriptionPayload

  """
  Generates a new set of recovery codes. The previous set (whatever it was) will be deleted!
  """
  generateAccountMultiFactorRecoveryCodes: GenerateAccountMultiFactorRecoveryCodesPayload

  """
  Generate a TOTP key for the current user. Recovery codes must be generated first.
  """
  generateAccountMultiFactorTotp: GenerateAccountMultiFactorTotpPayload

  """Generate a CCBill payment link to become a club supporter"""
  generateCCBillClubSupporterPaymentLink(input: GenerateCCBillClubSupporterPaymentLinkInput!): GenerateCCBillClubSupporterPaymentLinkPayload

  """Generate a payment receipt from the account transaction."""
  generateClubSupporterPaymentReceiptFromAccountTransaction(input: GenerateClubSupporterPaymentReceiptFromAccountTransactionInput!): GenerateClubSupporterPaymentReceiptFromAccountTransactionPayload

  """Generate a refund receipt from the account transaction."""
  generateClubSupporterRefundReceiptFromAccountTransaction(input: GenerateClubSupporterRefundReceiptFromAccountTransactionInput!): GenerateClubSupporterRefundReceiptFromAccountTransactionPayload

  """
  Generate a refund amount for a transaction.
  
  Staff+ only.
  """
  generateRefundAmountForAccountTransaction(input: GenerateRefundAmountForAccountTransactionInput!): GenerateRefundAmountForAccountTransactionPayload!

  """
  Grant account access with authentication token
  
  Should be used if the token does not require a multi-factor authentication step, and the token has to be
  verified first
  """
  grantAccountAccessWithAuthenticationToken(input: GrantAccountAccessWithAuthenticationTokenInput!): GrantAccountAccessWithAuthenticationTokenPayload

  """
  Grant account access using an authentication token and a multi factor option
  
  Set "recoveryCode" when authenticating with a recovery code
  """
  grantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCode(input: GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeInput!): GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodePayload

  """
  Grant account access using an authentication token and a multi factor option
  
  Set "code" when authenticating with a TOTP code
  """
  grantAccountAccessWithAuthenticationTokenAndMultiFactorTotp(input: GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpInput!): GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpPayload

  """
  Grant authentication token
  
  Authentication token can be used to login into a specific account, provided the token's value is first redeemed
  with the query
  """
  grantAuthenticationToken(input: GrantAuthenticationTokenInput!): GrantAuthenticationTokenPayload

  """Issue a club infraction."""
  issueClubInfraction(input: IssueClubInfractionInput!): IssueClubInfractionPayload

  """Join the club, becoming a member."""
  joinClub(input: JoinClubInput!): JoinClubPayload

  """
  Leave the club.
  
  If you are the owner of the club, you cannot leave the club.
  """
  leaveClub(input: LeaveClubInput!): LeaveClubPayload

  """Like a post"""
  likePost(input: LikePostInput!): LikePostPayload

  """Lock an account for a specific duration."""
  lockAccount(input: LockAccountInput!): LockAccountPayload

  """
  Make the alias slug the default, swapping out the old slug into the alias list.
  """
  promoteClubSlugAliasToDefault(input: PromoteClubSlugAliasToDefaultInput!): PromoteClubSlugAliasToDefaultPayload

  """
  Issue a refund on a transaction.
  
  Staff+ only.
  """
  refundAccountTransaction(input: RefundAccountTransactionInput!): RefundAccountTransactionPayload

  """
  Reject a specific post
  
  Moderator+ only
  """
  rejectPost(input: RejectPostInput!): RejectPostPayload

  """
  In case of a false infraction, you can remove it from the club's history.
  
  Staff+ only.
  """
  removeClubInfractionHistory(input: RemoveClubInfractionHistoryInput!): RemoveClubInfractionHistoryPayload

  """Remove an alternative slug from the club"""
  removeClubSlugAlias(input: RemoveClubSlugAliasInput!): RemoveClubSlugAliasPayload

  """
  Remove moderator from posts queue
  
  Moderator+ only
  """
  removeModeratorFromPostQueue(input: RemoveModeratorFromPostQueueInput!): RemoveModeratorFromPostQueuePayload

  """
  Remove a specific post, after a post has already been moderated
  
  Staff+ only
  """
  removePost(input: RemovePostInput!): RemovePostPayload

  """Update a post in draft status - remove content"""
  removePostContent(input: RemovePostContentInput!): RemovePostContentPayload

  """Report a specific post"""
  reportPost(input: ReportPostInput!): ReportPostPayload

  """Logout the current account"""
  revokeAccountAccess: RevokeAccountAccessPayload

  """Revoke the moderator role from the account"""
  revokeAccountModeratorRole(input: RevokeAccountModeratorRole!): RevokeAccountModeratorRolePayload

  """Revoke a session for this account"""
  revokeAccountSession(input: RevokeAccountSessionInput!): RevokeAccountSessionPayload

  """Revoke the staff role from the account"""
  revokeAccountStaffRole(input: RevokeAccountStaffRole!): RevokeAccountStaffRolePayload

  """
  Revoke authentication token
  
  Creating accounts and completing authentication flows will not be possible once it's revoked
  """
  revokeAuthenticationToken(input: RevokeAuthenticationTokenInput!): RevokeAuthenticationTokenPayload

  """Submit a post."""
  submitPost(input: SubmitPostInput!): SubmitPostPayload

  """
  Suspend the club.
  
  Staff+ only.
  """
  suspendClub(input: SuspendClubInput!): SuspendClubPayload

  """Un-archive a post, putting it back in public view."""
  unArchivePost(input: UnArchivePostInput!): UnArchivePostPayload

  """
  Un-Suspend the club. Suspension must be expired.
  
  Staff+ may un-suspend even if suspension hasn't expired yet.
  """
  unSuspendClub(input: UnSuspendClubInput!): UnSuspendClubPayload

  """Undo a like on a post"""
  undoLikePost(input: UndoLikePostInput!): UndoLikePostPayload

  """
  Unlock Account - account may be locked for any reason. Use this endpoint to unlock the account.
  
  Can be unlocked by staff+ regardless if time is past.
  """
  unlockAccount(input: UnlockAccountInput!): UnlockAccountPayload

  """
  Update the account email status to primary
  
  Cannot update if the email is not confirmed
  """
  updateAccountEmailStatusToPrimary(input: UpdateAccountEmailStatusToPrimaryInput!): UpdateAccountEmailStatusToPrimaryPayload

  """
  Update the language of the account.
  
  Note: that this is only a value, and in order to see anything in the browser, you should use the "UpdateLanguage" mutation.
  """
  updateAccountLanguage(input: UpdateAccountLanguageInput!): UpdateAccountLanguagePayload

  """
  Update the account username
  
  Will retain the old username
  """
  updateAccountUsername(input: UpdateAccountUsernameInput!): UpdateAccountUsernamePayload

  """Update audience standard"""
  updateAudienceIsStandard(input: UpdateAudienceIsStandardInput!): UpdateAudienceIsStandardPayload

  """Update audience thumbnail"""
  updateAudienceThumbnail(input: UpdateAudienceThumbnailInput!): UpdateAudienceThumbnailPayload

  """Update audience title"""
  updateAudienceTitle(input: UpdateAudienceTitleInput!): UpdateAudienceTitlePayload

  """Update a reason deprecation."""
  updateCancellationReasonDeprecated(input: UpdateCancellationReasonDeprecatedInput!): UpdateCancellationReasonDeprecatedPayload

  """Update a reason title."""
  updateCancellationReasonTitle(input: UpdateCancellationReasonTitleInput!): UpdateCancellationReasonTitlePayload

  """Update category thumbnail"""
  updateCategoryThumbnail(input: UpdateCategoryThumbnailInput!): UpdateCategoryThumbnailPayload

  """Update category title"""
  updateCategoryTitle(input: UpdateCategoryTitleInput!): UpdateCategoryTitlePayload

  """Update character title"""
  updateCharacterName(input: UpdateCharacterNameInput!): UpdateCharacterNamePayload

  """Update character thumbnail"""
  updateCharacterThumbnail(input: UpdateCharacterThumbnailInput!): UpdateCharacterThumbnailPayload

  """Update the club's name (english-only for now)"""
  updateClubName(input: UpdateClubNameInput!): UpdateClubNamePayload

  """Update the club thumbnail"""
  updateClubThumbnail(input: UpdateClubThumbnailInput!): UpdateClubThumbnailPayload

  """Update the audience for the curation profile"""
  updateCurationProfileAudience(input: UpdateCurationProfileAudienceInput!): UpdateCurationProfileAudiencePayload

  """Update the category for the curation profile"""
  updateCurationProfileCategory(input: UpdateCurationProfileCategoryInput!): UpdateCurationProfileCategoryPayload

  """Update the date of birth for the curation profile"""
  updateCurationProfileDateOfBirth(input: UpdateCurationProfileDateOfBirthInput!): UpdateCurationProfileDateOfBirthPayload

  """Update the current language."""
  updateLanguage(input: UpdateLanguageInput!): UpdateLanguagePayload

  """Update a post in draft status - audience"""
  updatePostAudience(input: UpdatePostAudienceInput!): UpdatePostAudiencePayload

  """Update a post in draft status - categories"""
  updatePostCategories(input: UpdatePostCategoriesInput!): UpdatePostCategoriesPayload

  """Update a post in draft status - characters"""
  updatePostCharacters(input: UpdatePostCharactersInput!): UpdatePostCharactersPayload

  """Update a post content - whether or not it is supporter only"""
  updatePostContentIsSupporterOnly(input: UpdatePostContentIsSupporterOnlyInput!): UpdatePostContentIsSupporterOnlyPayload

  """
  Update a post in draft status - update post content order - need to send exact same IDs
  """
  updatePostContentOrder(input: UpdatePostContentOrderInput!): UpdatePostContentOrderPayload

  """Update a rule deprecation."""
  updateRuleDeprecated(input: UpdateRuleDeprecatedInput!): UpdateRuleDeprecatedPayload

  """Update a rule description."""
  updateRuleDescription(input: UpdateRuleDescriptionInput!): UpdateRuleDescriptionPayload

  """Update a rule infraction."""
  updateRuleInfraction(input: UpdateRuleInfractionInput!): UpdateRuleInfractionPayload

  """Update a rule title."""
  updateRuleTitle(input: UpdateRuleTitleInput!): UpdateRuleTitlePayload

  """Update series thumbnail"""
  updateSeriesThumbnail(input: UpdateSeriesThumbnailInput!): UpdateSeriesThumbnailPayload

  """Update series title"""
  updateSeriesTitle(input: UpdateSeriesTitleInput!): UpdateSeriesTitlePayload

  """
  Will verify the authentication token. Requires the secret (sent in an email)
  """
  verifyAuthenticationToken(input: VerifyAuthenticationTokenInput!): VerifyAuthenticationTokenPayload
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

"""A payment method."""
type PaymentMethod {
  """Billing address of this card."""
  billingAddress: BillingAddress

  """Billing contact of this card."""
  billingContact: BillingContact

  """Card linked to this payment method."""
  card: Card!
}

type Post implements Node {
  """Represents the audience that this post belongs to"""
  audience: Audience

  """Audit logs belonging to this pending post"""
  auditLogs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostAuditLogConnection!

  """Categories that belong to this post"""
  categories: [Category!]!

  """Characters that belong to this post"""
  characters: [Character!]!

  """The club belonging to the post"""
  club: Club!

  """Content belonging to this post"""
  content: [PostContent!]!

  """The contributor who contributed this post"""
  contributor: Account!

  """The date and time of when this post was created"""
  createdAt: Time!
  id: ID!

  """The amount of likes on this post."""
  likes: Int!

  """The date and time of when this post was posted"""
  postedAt: Time

  """
  The reference of this post. Should always be used to reference this post.
  """
  reference: String!

  """Reports belonging to a post"""
  reports(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """From which date the post reports should be shown."""
    from: Time!

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    The end date of the post reports. Optional - if not specified, will search through all-time.
    """
    to: Time
  ): PostReportConnection!

  """
  If this post was removed or rejected from the moderator queue, you can view the rule that was cited.
  """
  rule: Rule

  """The state of the post."""
  state: PostState!

  """Suggested posts for this post."""
  suggestedPosts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostConnection!

  """The supporter-only status."""
  supporterOnlyStatus: SupporterOnlyStatus!

  """Whether or not the viewer liked this post."""
  viewerLiked: PostLike

  """Whether or not the post was reported by the viewer."""
  viewerReport: PostReport
}

"""
Post audit log

Audit log is created when a moderator takes an action against a pending post
"""
type PostAuditLog implements Node {
  """The status or the action that was taken against the pending post"""
  action: PostAuditLogAction!

  """ID of the audit log"""
  id: ID!

  """The moderator that this log belongs to"""
  moderator: Account!

  """Additional notes by the moderator"""
  notes: String

  """The post linked to this audit log"""
  post: Post!

  """If a post was removed or rejected, this is the rule that was cited."""
  rule: Rule
}

enum PostAuditLogAction {
  APPROVED
  DENIED
  REMOVED
}

"""Connection of the audit log"""
type PostAuditLogConnection {
  edges: [PostAuditLogEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the audit log"""
type PostAuditLogEdge {
  cursor: String!
  node: PostAuditLog!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

"""Represents content for a post."""
type PostContent {
  """The ID of this content."""
  id: ID!

  """Whether or not this content is supporter only."""
  isSupporterOnly: Boolean!

  """The resource belonging to this content."""
  resource: Resource!

  """Whether or not the viewer is able to see this content."""
  viewerCanViewSupporterOnlyContent: Boolean!
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PostLike implements Node {
  """The account this like belongs to"""
  account: Account!

  """An ID uniquely identifying this like."""
  id: ID!

  """The time and date at which the post was liked."""
  likedAt: Time!

  """The post this like belongs to."""
  post: Post!
}

type PostModerator {
  """The ID to identify this post moderator item."""
  id: ID!

  """The moderator.."""
  moderator: Account!

  """When this post queue item was initially placed in the queue."""
  placedAt: Time!

  """The post linked to this post moderator."""
  post: Post!

  """When this post queue item will be reassigned."""
  reassignmentAt: Time!
}

type PostModeratorConnection {
  edges: [PostModeratorEdge!]!
  pageInfo: PageInfo!
}

type PostModeratorEdge {
  cursor: String!
  node: PostModerator!
}

"""Post report"""
type PostReport implements Node {
  """The account that initiated this report"""
  account: Account!

  """ID of the report"""
  id: ID!

  """The post linked to this report."""
  post: Post!

  """The rule that was cited for this report."""
  rule: Rule!
}

"""Connection of the post report"""
type PostReportConnection {
  edges: [PostReportEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the post report"""
type PostReportEdge {
  cursor: String!
  node: PostReport!
}

"""Properties by which posts connections can be sorted."""
enum PostsSort {
  """Posts by newest first"""
  NEW

  """Posts by top likes"""
  TOP
}

enum PostState {
  ARCHIVED
  DISCARDED
  DRAFT
  PUBLISHED
  REJECTED
  REMOVED
  REVIEW
}

"""Type describing a price."""
type Price {
  """
  The amount.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  amount: Int!

  """The currency the amount is represented in."""
  currency: Currency!
}

"""Update alias slug to default."""
input PromoteClubSlugAliasToDefaultInput {
  """The club to update"""
  id: ID!

  """The chosen slug for the club."""
  slug: String!
}

"""Payload for a new alt slug"""
type PromoteClubSlugAliasToDefaultPayload {
  """The club after update"""
  club: Club
}

type Query {
  """Look up a single account"""
  account(
    """Look up a post by a username"""
    username: String!
  ): Account

  """Grab a single account subscription by the reference."""
  accountClubSupporterSubscription(reference: String!): AccountClubSupporterSubscription

  """Grab a single account transaction by the reference."""
  accountTransaction(reference: String!): AccountTransaction

  """Get a single audience."""
  audience(
    """Search by slug of the audience."""
    slug: String!
  ): Audience

  """Search all audiences."""
  audiences(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by audience slugs."""
    slugs: [String!]

    """Sorting options for audiences."""
    sortBy: AudiencesSort! = POPULAR

    """Search by title of the audience."""
    title: String
  ): AudienceConnection!

  """Get a cancellation reason by reference."""
  cancellationReason(reference: String!): CancellationReason

  """Get all reasons for the site."""
  cancellationReasons(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Whether or not to show deprecated reasons."""
    deprecated: Boolean! = false

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CancellationReasonConnection!

  """Search all categories."""
  categories(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by category slugs."""
    slugs: [String!]

    """Sorting options for categories."""
    sortBy: CategoriesSort! = POPULAR

    """Filter by the title of the category."""
    title: String
  ): CategoryConnection!

  """Get a single category."""
  category(
    """Search by slug of the category."""
    slug: String!
  ): Category

  """
  Grab more details about a ccbill subscription, passing in the ID.
  
  Staff+ only.
  """
  ccbillSubscriptionDetails(ccbillSubscriptionId: String!): CCBillSubscriptionDetails

  """
  After a successful transaction (through CCBill FlexForms or becomeClubSupporterWithAccountSavedPaymentMethod),
  use the returned token in this query to grab the current state of the transaction.
  
  It will tell you if the transaction was approved or denied, as well as having the ability to poll until a subscription is finalized.
  """
  ccbillTransactionDetails(token: String!): CCBillTransactionDetails

  """Get a single character."""
  character(
    """A series slug is required since character slugs are unique-per-series."""
    seriesSlug: String!

    """Search by slug of the character."""
    slug: String!
  ): Character

  """Get or search all characters"""
  characters(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the character."""
    name: String

    """
    When searching for a character by slug, you need to include the series' slug since slugs are unique-per-series.
    
    Only one slug is allowed for now since you don't want inaccurate results
    """
    seriesSlug: String

    """Search by character slugs."""
    slugs: [String!]

    """Sorting options for characters."""
    sortBy: CharactersSort! = POPULAR
  ): CharacterConnection!

  """Get a single club."""
  club(
    """Search by slug of the club."""
    slug: String!
  ): Club

  """Search multiple clubs."""
  clubs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the club."""
    name: String

    """Search by club slugs."""
    slugs: [String!]

    """Sorting options for clubs."""
    sortBy: ClubsSort! = POPULAR
  ): ClubConnection!

  """
  The current language that is set
  
  Note: this is only temporary, per-browser language
  
  For a permanent language on an account level, see "Language" as part of viewer
  """
  language: Language!

  """List of all available languages"""
  languages: [Language!]!

  """Look up a single post"""
  post(
    """Look up a post by a reference #"""
    reference: String!
  ): Post

  """All post reports."""
  postReports(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """From which date the post reports should be shown."""
    from: Time!

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    The end date of the post reports. Optional - if not specified, will search through all-time.
    """
    to: Time
  ): PostReportConnection!

  """Search multiple posts"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """Posts feed. The default."""
  postsFeed(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostConnection!

  """Get a single rule by reference."""
  rule(reference: String!): Rule

  """Get all rules for the site."""
  rules(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Whether or not to show deprecated rules."""
    deprecated: Boolean! = false

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): RuleConnection!

  """Get a single serial."""
  serial(
    """Search by slug of the serial."""
    slug: String!
  ): Series

  """Get or search all series"""
  series(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    slugs: [String!]

    """Sorting options for series."""
    sortBy: SeriesSort! = POPULAR

    """Filter by the title of the series."""
    title: String
  ): SeriesConnection!

  """
  Get the status of the authentication token - whether or not it is redeemed, account status, etc..
  
  Note: you can only view the authentication token if you're the originating device or you have entered a valid secret (not from same device)
  """
  viewAuthenticationToken(secret: String, token: String!): AuthenticationToken

  """Get the currently-authenticated account"""
  viewer: Account
}

"""Refund an account transaction."""
input RefundAccountTransactionInput {
  """The id of the subscription."""
  accountTransactionId: ID!

  """
  The amount to refund.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  amount: Int!
}

"""Payload for refunding an account transaction."""
type RefundAccountTransactionPayload {
  """The updated account transaction."""
  accountTransaction: AccountTransaction
}

"""A generated refund amount."""
type RefundAmount {
  """The currency."""
  currency: Currency!

  """
  The maximum amount you can issue a refund for.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  maximumAmount: Int!

  """
  A prorated refund amount, based on the first date and last date of billing / billing duration.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  proratedAmount: Int!
}

"""Moderate the pending post input"""
input RejectPostInput {
  """Any extra notes for the moderator"""
  notes: String

  """Pending post to take action against"""
  postId: ID!

  """Required to enter a rule ID."""
  ruleId: ID!
}

"""Reject the pending post payload"""
type RejectPostPayload {
  """The resulting post"""
  post: Post
}

"""Remove a club infraction."""
input RemoveClubInfractionHistoryInput {
  """The history item to remove."""
  clubInfractionHistoryId: ID!
}

"""Remove club infraction history."""
type RemoveClubInfractionHistoryPayload {
  """The removed infraction history Id."""
  clubInfractionHistoryId: ID!
}

"""Remove alias slug."""
input RemoveClubSlugAliasInput {
  """The club to update"""
  id: ID!

  """The chosen slug for the club."""
  slug: String!
}

"""Payload for a new alt slug"""
type RemoveClubSlugAliasPayload {
  """The club after update"""
  club: Club
}

"""Remove moderator from posts queue."""
input RemoveModeratorFromPostQueueInput {
  """The moderator account to take the action on"""
  accountId: ID!
}

"""Remove moderator from posts queue."""
type RemoveModeratorFromPostQueuePayload {
  """The account that was updated"""
  account: Account
}

"""Remove post content."""
input RemovePostContentInput {
  """Content IDs for the content"""
  contentIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type RemovePostContentPayload {
  """The post after the update"""
  post: Post
}

"""Moderate the pending post input"""
input RemovePostInput {
  """Any extra notes for the staff member"""
  notes: String

  """Pending post to take action against"""
  postId: ID!

  """Required to enter a rule ID."""
  ruleId: ID!
}

"""Remove the pending post payload"""
type RemovePostPayload {
  """The resulting post"""
  post: Post
}

"""Report the post input"""
input ReportPostInput {
  """The post to report"""
  postId: ID!

  """The rule to report this post for."""
  ruleId: ID!
}

"""Report the post payload"""
type ReportPostPayload {
  """The post report that was generated"""
  postReport: PostReport
}

"""
A resource represents an image or a video format that contains an ID to uniquely identify it,
and urls to access the resources. We have many urls in order to provide a fallback for older browsers

We also identify the type of resource (image or video) to make it easy to distinguish them
"""
type Resource {
  """The height."""
  height: Int!

  """An ID uniquely identifying this resource."""
  id: ID!

  """
  Whether or not the resource is processed. Can be used for additional permission checks.
  """
  processed: Boolean!

  """The type of resource - either an image or a video."""
  type: ResourceType!

  """URLs to access the resource."""
  urls: [ResourceUrl!]!

  """Duration, if video."""
  videoDuration: Int!

  """Video thumbnail, if video."""
  videoThumbnail: ResourceUrl

  """The width."""
  width: Int!
}

"""Identifies the type of resource"""
enum ResourceType {
  IMAGE
  VIDEO
}

"""A type representing a url to the resource and the mimetype"""
type ResourceUrl {
  mimeType: String!
  url: URI!
}

"""Payload for revoking the current viewer"""
type RevokeAccountAccessPayload {
  """The account that was revoked"""
  revokedAccountId: ID!
}

"""Input to revoke moderator role"""
input RevokeAccountModeratorRole {
  """The account ID that the role needs to be revoked from"""
  accountId: ID!
}

"""Revoked account"""
type RevokeAccountModeratorRolePayload {
  """The account that the role was revoked from"""
  account: Account
}

"""Input for updating an account's username"""
input RevokeAccountSessionInput {
  """Session ID that should be revoked"""
  accountSessionId: ID!
}

"""Payload of the revoked account session"""
type RevokeAccountSessionPayload {
  """The ID of the session that was revoked"""
  accountSessionId: ID!
}

"""Input to revoke staff role"""
input RevokeAccountStaffRole {
  """The account ID that the role needs to be revoked from"""
  accountId: ID!
}

"""Revoked account"""
type RevokeAccountStaffRolePayload {
  """The account that the role was revoked from"""
  account: Account
}

"""Input for revoking an authentication token"""
input RevokeAuthenticationTokenInput {
  """
  The secret associated with this token. Required if revoking the token not on the same device that created it.
  """
  secret: String

  """The token to revoke"""
  token: String!
}

"""Payload for revoking the authentication token"""
type RevokeAuthenticationTokenPayload {
  """The authentication token that was removed"""
  revokedAuthenticationTokenId: ID!
}

"""Rule."""
type Rule implements Node {
  """If this rule is deprecated."""
  deprecated: Boolean!

  """The description for this rule."""
  description: String!

  """All translations for this description."""
  descriptionTranslations: [Translation!]!

  """ID of the rule."""
  id: ID!

  """
  If breaking this rule would cause an infraction - used for when posts are rejected or removed and this rule is applied.
  """
  infraction: Boolean!

  """Reference of the rule. Should be used for single lookups."""
  reference: String!

  """The title for this rule."""
  title: String!

  """All translations for this title."""
  titleTranslations: [Translation!]!
}

"""Connection of the rule"""
type RuleConnection {
  edges: [RuleEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the rule"""
type RuleEdge {
  cursor: String!
  node: Rule!
}

type Series implements Node {
  """An ID pointing to this series."""
  id: ID!

  """Posts belonging to this series"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """A title for this series."""
  title: String!

  """All translations for this title."""
  titleTranslations: [Translation!]!

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type SeriesConnection {
  edges: [SeriesEdge!]!
  pageInfo: PageInfo!
}

type SeriesEdge {
  cursor: String!
  node: Series!
}

"""Properties by which series connections can be sorted."""
enum SeriesSort {
  """Series by newest first"""
  NEW

  """Series by most posts"""
  POPULAR

  """Series by top likes"""
  TOP
}

"""Publish post."""
input SubmitPostInput {
  """The post to publish"""
  id: ID!
}

"""Payload for submitting a post"""
type SubmitPostPayload {
  """The post after being submitted"""
  post: Post
}

enum SupporterOnlyStatus {
  """All of the content is supporter-only."""
  FULL

  """None of the content requires supporting to view."""
  NONE

  """
  Some of the content requires supporting to view, at least 1 content piece is free.
  """
  PARTIAL
}

"""Suspend the club."""
input SuspendClubInput {
  """The club to suspend."""
  clubId: ID!

  """When the suspension should end."""
  endTime: Time!
}

"""Suspend club payload."""
type SuspendClubPayload {
  """The new club after it's suspended."""
  club: Club
}

scalar Time

type Translation {
  """The language linked to this translation."""
  language: Language!

  """The translation text."""
  text: String!
}

"""Un-Archive post."""
input UnArchivePostInput {
  """The post to un-archive"""
  id: ID!
}

"""Payload for un-archiving a post"""
type UnArchivePostPayload {
  """The un-archived post."""
  post: Post
}

"""Undo like on a post."""
input UndoLikePostInput {
  """The post ID that you want to unlike"""
  id: ID!
}

"""Payload for undoing a post like"""
type UndoLikePostPayload {
  """The post like that was deleted."""
  postLikeId: ID
}

"""Input for unlocking an account"""
input UnlockAccountInput {
  """The account to unlock."""
  accountID: ID!
}

"""Payload for the unlocked account"""
type UnlockAccountPayload {
  """Account that was unlocked"""
  account: Account
}

"""Un-Suspend the club."""
input UnSuspendClubInput {
  """The club to un-suspend."""
  clubId: ID!
}

"""Un suspend club payload."""
type UnSuspendClubPayload {
  """The new club after it's not suspended anymore."""
  club: Club
}

"""Input for updating the account status to primary"""
input UpdateAccountEmailStatusToPrimaryInput {
  """The email that should be updated"""
  accountEmailId: ID!
}

"""Payload of the updated account email"""
type UpdateAccountEmailStatusToPrimaryPayload {
  """The account email that was updated to primary"""
  primaryAccountEmail: AccountEmail

  """The account email that was updated to 'confirmed' status"""
  updatedAccountEmail: AccountEmail
}

"""Input for updating the account language"""
input UpdateAccountLanguageInput {
  """The locale to update the language to"""
  locale: BCP47!
}

"""Payload of the account language update"""
type UpdateAccountLanguagePayload {
  """The account that has the updated language"""
  Account: Account

  """The new language that is now set"""
  language: Language
}

"""Input for updating an account's username"""
input UpdateAccountUsernameInput {
  """The username that the account should be updated to"""
  username: String!
}

"""Payload of the updated username"""
type UpdateAccountUsernamePayload {
  """The account that was modified"""
  account: Account

  """Validation for taking an account username"""
  validation: UpdateAccountUsernameValidation
}

"""Validation message for updating account username"""
enum UpdateAccountUsernameValidation {
  USERNAME_TAKEN
}

"""Update audience."""
input UpdateAudienceIsStandardInput {
  """The audience to update"""
  id: ID!

  """Standard"""
  standard: Boolean!
}

"""Payload for updating audience"""
type UpdateAudienceIsStandardPayload {
  """The audience after update"""
  audience: Audience
}

"""Update audience."""
input UpdateAudienceThumbnailInput {
  """The audience to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating audience"""
type UpdateAudienceThumbnailPayload {
  """The audience after update"""
  audience: Audience
}

"""Update audience."""
input UpdateAudienceTitleInput {
  """The audience to update"""
  id: ID!

  """The localization for this title"""
  locale: BCP47!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating audience"""
type UpdateAudienceTitlePayload {
  """The audience after update"""
  audience: Audience
}

"""Update reason."""
input UpdateCancellationReasonDeprecatedInput {
  """The cancellation reason to update."""
  cancellationReasonId: ID!

  """The deprecated status."""
  deprecated: Boolean!
}

"""Updated reason."""
type UpdateCancellationReasonDeprecatedPayload {
  """The updated reason."""
  cancellationReason: CancellationReason
}

"""Update cancellation reason."""
input UpdateCancellationReasonTitleInput {
  """The reason to update."""
  cancellationReasonId: ID!

  """The localization for this title."""
  locale: BCP47!

  """The title to update"""
  title: String!
}

"""Updated reason."""
type UpdateCancellationReasonTitlePayload {
  """The updated reason."""
  cancellationReason: CancellationReason
}

"""Update category."""
input UpdateCategoryThumbnailInput {
  """The category to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating category"""
type UpdateCategoryThumbnailPayload {
  """The category after update"""
  category: Category
}

"""Update category."""
input UpdateCategoryTitleInput {
  """The category to update"""
  id: ID!

  """The localization for this title"""
  locale: BCP47!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating category"""
type UpdateCategoryTitlePayload {
  """The category after update"""
  category: Category
}

"""Update character."""
input UpdateCharacterNameInput {
  """The character to update"""
  id: ID!

  """
  The localization for this name.
  
  Validation: Must be one of the languages from the languages query.
  """
  locale: BCP47!

  """
  The name to update.
  
  Validation: Max 25 characters.
  """
  name: String!
}

"""Payload for updating character"""
type UpdateCharacterNamePayload {
  """The character after update"""
  character: Character
}

"""Update character."""
input UpdateCharacterThumbnailInput {
  """The character to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating character"""
type UpdateCharacterThumbnailPayload {
  """The character after update"""
  character: Character
}

"""Update club name."""
input UpdateClubNameInput {
  """The club to update"""
  id: ID!

  """
  The chosen name for the club.
  
  Validation: Max 25 characters.
  """
  name: String!
}

"""Payload for updating the name"""
type UpdateClubNamePayload {
  """The club after update"""
  club: Club
}

"""Update club thumbnail."""
input UpdateClubThumbnailInput {
  """The club to update"""
  id: ID!

  """The thumbnail for the club."""
  thumbnail: String!
}

"""Payload for updating the thumbnail"""
type UpdateClubThumbnailPayload {
  """The club after update"""
  club: Club
}

"""Update curation profile audience."""
input UpdateCurationProfileAudienceInput {
  """The audiences that were selected"""
  audienceIds: [ID!]!

  """Whether or not this section was skipped"""
  skipped: Boolean!
}

"""Payload for updating profile audience"""
type UpdateCurationProfileAudiencePayload {
  """The updated profile."""
  curationProfile: CurationProfile
}

"""Update curation profile category."""
input UpdateCurationProfileCategoryInput {
  """The categories that were selected"""
  categoryIds: [ID!]!

  """Whether or not this section was skipped"""
  skipped: Boolean!
}

"""Payload for updating profile category"""
type UpdateCurationProfileCategoryPayload {
  """The updated profile."""
  curationProfile: CurationProfile
}

"""Update curation profile date of birth."""
input UpdateCurationProfileDateOfBirthInput {
  """The date of birth that was selected"""
  dateOfBirth: Time

  """Whether or not this section was skipped"""
  skipped: Boolean!
}

"""Payload for updating profile date of birth"""
type UpdateCurationProfileDateOfBirthPayload {
  """The updated profile."""
  curationProfile: CurationProfile
}

"""Input for updating the current language"""
input UpdateLanguageInput {
  """The locale to update the language to"""
  locale: BCP47!
}

"""Payload of the language update"""
type UpdateLanguagePayload {
  """The new language that is now set"""
  language: Language
}

"""Update post audience."""
input UpdatePostAudienceInput {
  """The audience that this post belongs to"""
  audienceId: ID!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostAudiencePayload {
  """The post after the update"""
  post: Post
}

"""Update post audience."""
input UpdatePostCategoriesInput {
  """Category IDs for this post"""
  categoryIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostCategoriesPayload {
  """The post after the update"""
  post: Post
}

"""Update post characters."""
input UpdatePostCharactersInput {
  """Ids for all the characters"""
  characterIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostCharactersPayload {
  """The post after the update"""
  post: Post
}

"""Payload for updating a post"""
type UpdatePostClubPayload {
  """The post after the update"""
  post: Post
}

"""Update post content is supporter only."""
input UpdatePostContentIsSupporterOnlyInput {
  """Content IDs to update"""
  contentIds: [ID!]!

  """The post to update"""
  id: ID!

  """The change to make"""
  isSupporterOnly: Boolean!
}

"""Payload for updating a post"""
type UpdatePostContentIsSupporterOnlyPayload {
  """The post after the update"""
  post: Post
}

"""Update post content order."""
input UpdatePostContentOrderInput {
  """Content IDs for the content"""
  contentIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostContentOrderPayload {
  """The post after the update"""
  post: Post
}

"""Update post report reason."""
input UpdateRuleDeprecatedInput {
  """The deprecated status."""
  deprecated: Boolean!

  """The rule to update."""
  ruleId: ID!
}

"""Updated rule."""
type UpdateRuleDeprecatedPayload {
  """The updated rule."""
  rule: Rule
}

"""Update rule."""
input UpdateRuleDescriptionInput {
  """
  The description to update.
  
  Validation: Max 25 characters. Markdown allowed.
  """
  description: String!

  """The localization for this description."""
  locale: BCP47!

  """The rule to update."""
  ruleId: ID!
}

"""Updated rule."""
type UpdateRuleDescriptionPayload {
  """The updated rule."""
  rule: Rule
}

"""Update post report reason."""
input UpdateRuleInfractionInput {
  """The infraction status."""
  infraction: Boolean!

  """The rule to update."""
  ruleId: ID!
}

"""Updated rule."""
type UpdateRuleInfractionPayload {
  """The updated rule."""
  rule: Rule
}

"""Update rule."""
input UpdateRuleTitleInput {
  """The localization for this title."""
  locale: BCP47!

  """The rule to update."""
  ruleId: ID!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Updated rule."""
type UpdateRuleTitlePayload {
  """The updated rule."""
  rule: Rule
}

"""Update series."""
input UpdateSeriesThumbnailInput {
  """The series to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating series"""
type UpdateSeriesThumbnailPayload {
  """The category after update"""
  series: Series
}

"""Update series."""
input UpdateSeriesTitleInput {
  """The series to update"""
  id: ID!

  """
  The localization for this title.
  
  Locale must be one from the languages query, or else the locale won't be accepted.
  """
  locale: BCP47!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating series"""
type UpdateSeriesTitlePayload {
  """The series after update"""
  series: Series
}

"""An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string."""
scalar URI

"""Input for verifying authentication token"""
input VerifyAuthenticationTokenInput {
  """Secret (get it from the email)"""
  secret: String!

  """The original token"""
  token: String!
}

"""Payload for verifying the authentication token"""
type VerifyAuthenticationTokenPayload {
  """The authentication token"""
  authenticationToken: AuthenticationToken

  """Validation options"""
  validation: VerifyAuthenticationTokenValidation
}

"""Validation for granting account access"""
enum VerifyAuthenticationTokenValidation {
  TOKEN_INVALID
}
