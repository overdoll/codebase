"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

type Account implements Node {
  """A URL pointing to the account's public avatar."""
  avatar: Resource

  """Privileged users cannot disable MFA (moderators, staff)"""
  canDisableMultiFactor: Boolean!

  """Posts feed for the clubs that the account currently is a member of."""
  clubMembersPostsFeed(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostConnection!

  """Represents the club memberships that the account has."""
  clubMemberships(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """sorting options for club members."""
    sortBy: ClubMembersSort! = NEWEST

    """Filter by whether or not this is a supporter."""
    supporter: Boolean! = false
  ): ClubMemberConnection!

  """
  Current count of club memberships. Should be compared against the limit before joining a club.
  """
  clubMembershipsCount: Int!

  """Maximum amount of clubs that you can join as an account."""
  clubMembershipsLimit: Int!

  """Club supporter subscriptions linked to this account."""
  clubSupporterSubscriptions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of account club supporter subscription status."""
    status: [AccountClubSupporterSubscriptionStatus!]
  ): AccountClubSupporterSubscriptionConnection!

  """Represents the clubs that the account has created."""
  clubs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the club."""
    name: String

    """Search by club slugs."""
    slugs: [String!]

    """Sorting options for clubs."""
    sortBy: ClubsSort! = POPULAR
  ): ClubConnection!

  """Current count of the amount of clubs that the account has created."""
  clubsCount: Int!

  """Maximum amount of clubs that you can create."""
  clubsLimit: Int!

  """The curation profile linked to this account."""
  curationProfile: CurationProfile!

  """The details of a deleting state."""
  deleting: AccountDeleting

  """
  Details belonging to this account.
  
  If null, account details have not been filled out yet.
  
  Account details are required to be filled out before setting a payout method.
  """
  details: AccountDetails

  """
  Emails for account (multiple emails per account)
  
  Only queryable if the currently logged-in account belongs to the requested account
  """
  emails(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AccountEmailConnection!

  """Maximum amount of emails that this account can create"""
  emailsLimit: Int!

  """Expired club supporter subscriptions linked to this account."""
  expiredClubSupporterSubscriptions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ExpiredAccountClubSupporterSubscriptionConnection!

  """
  Whether or not this account has at least 1 active or cancelled club supporter subscription.
  
  This should be false in order to delete the account.
  """
  hasActiveOrCancelledAccountClubSupporterSubscriptions: Boolean!

  """
  Whether or not this club has non-terminated clubs.
  
  Cannot delete account if this is true.
  """
  hasNonTerminatedClubs: Boolean!

  """ID representing the account"""
  id: ID!

  """Whether or not this account is an artist"""
  isArtist: Boolean!

  """
  Whether or not this account is deleted.
  
  When an account is deleted, the username, email and any other data is blank.
  """
  isDeleted: Boolean!

  """Whether or not this account is part of the moderation team"""
  isModerator: Boolean!

  """
  Whether or not this account is secure.
  
  At the moment, an account is secure once they have two factor authentication enabled. This may include future conditions.
  """
  isSecure: Boolean!

  """Whether or not this account is a staff member"""
  isStaff: Boolean!

  """The details of the account lock."""
  lock: AccountLock

  """
  Moderator settings and status for this account
  
  Viewable by the currently authenticated account or staff+
  """
  moderatorSettings: ModeratorSettings!

  """Is multi factor enabled - can be toggled off if they want to"""
  multiFactorEnabled: Boolean!

  """
  Has TOTP been configured? Recovery codes must be generated before configuring
  """
  multiFactorTotpConfigured: Boolean!

  """The account payout method linked to this account."""
  payoutMethod: AccountPayoutMethod

  """
  Post Audit Logs linked to this account
  
  Viewable by either the currently logged-in account or staff+
  """
  postAuditLogs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """From which date the audit logs should be shown."""
    from: Time!

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    The end date of the audit logs. Optional - if not specified, will search through all-time.
    """
    to: Time
  ): PostAuditLogConnection!

  """Posts queue specific to this account (when moderator)"""
  postModeratorQueue(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostModeratorConnection!

  """Contributions specific to this account"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """
  MFA Recovery codes belonging to this account
  
  Only queryable if the currently logged-in account belongs to the requested account
  """
  recoveryCodes: [AccountMultiFactorRecoveryCode!]!

  """
  Have recovery codes been generated? Required in order to configure TOTP
  """
  recoveryCodesGenerated: Boolean!

  """The ID that the account can be referenced by"""
  reference: String!

  """Saved payment methods linked to this account."""
  savedPaymentMethods(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AccountSavedPaymentMethodConnection!

  """
  Sessions linked to this account
  
  Only queryable if the currently logged-in account belongs to the requested account
  """
  sessions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): AccountSessionConnection!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """Total amount of chargeback transactions."""
  transactionsChargebackCount: Int!

  """Total amount of payment transactions."""
  transactionsPaymentCount: Int!

  """Total amount of refund transactions."""
  transactionsRefundCount: Int!

  """Total amount of transactions, excluding voids."""
  transactionsTotalCount: Int!

  """The username of the account."""
  username: String!

  """The next time the username is available to be changed"""
  usernameEditAvailableAt: Time!
}

type AccountActiveClubSupporterSubscription implements IAccountClubSupporterSubscription & Node {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """The last billing date for this subscription."""
  lastBillingDate: Date!

  """The next billing date for this subscription."""
  nextBillingDate: Date!

  """The payment method linked to this subscription."""
  paymentMethod: PaymentMethod!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

type AccountCancelledClubSupporterSubscription implements IAccountClubSupporterSubscription & Node {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The reason this subscription was cancelled, if there is one."""
  cancellationReason: CancellationReason

  """When this subscription was cancelled."""
  cancelledAt: Time!

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """When this subscription will end."""
  endDate: Date!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """The payment method linked to this subscription."""
  paymentMethod: PaymentMethod!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

union AccountClubSupporterSubscription = AccountActiveClubSupporterSubscription | AccountCancelledClubSupporterSubscription | AccountExpiredClubSupporterSubscription

type AccountClubSupporterSubscriptionBillingError {
  """The decline error, parsed in a friendlier way."""
  ccbillDeclineError: CCBillDeclineError

  """The error code from CCBill."""
  ccbillErrorCode: String

  """The error text from CCBill."""
  ccbillErrorText: String

  """When this subscription failed to bill."""
  failedAt: Time!

  """The next date the billing will be retried."""
  nextRetryDate: Date!
}

"""Connection of the account club supporter subscription"""
type AccountClubSupporterSubscriptionConnection {
  edges: [AccountClubSupporterSubscriptionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account club supporter subscriptions"""
type AccountClubSupporterSubscriptionEdge {
  cursor: String!
  node: AccountClubSupporterSubscription!
}

enum AccountClubSupporterSubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

type AccountDeleting {
  scheduledDeletion: Time!
}

"""Details belonging to an account."""
type AccountDetails {
  """The country this account belongs to."""
  country: Country!

  """The first name belonging to this account."""
  firstName: String!

  """An ID to uniquely identify this details instance."""
  id: ID!

  """The last name belonging to this account."""
  lastName: String!
}

"""Email belonging to a specific account"""
type AccountEmail implements Node {
  """
  The account that this email belongs to
  
  May be null because unconfirmed emails are not yet actually attached to the account
  """
  account: Account

  """The account email"""
  email: String!

  """ID of the account email"""
  id: ID!

  """The current status of the account email"""
  status: AccountEmailStatus!
}

"""Connection of the account email"""
type AccountEmailConnection {
  edges: [AccountEmailEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account email"""
type AccountEmailEdge {
  cursor: String!
  node: AccountEmail!
}

enum AccountEmailStatus {
  CONFIRMED
  PRIMARY
  UNCONFIRMED
}

type AccountExpiredClubSupporterSubscription implements IAccountClubSupporterSubscription & Node {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The reason this subscription was cancelled, if there is one."""
  cancellationReason: CancellationReason

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """When this subscription expired."""
  expiredAt: Time!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

type AccountLock {
  expires: Time!
}

"""The multi-factor recovery code belonging to the account"""
type AccountMultiFactorRecoveryCode {
  """The multi factor recovery code"""
  code: String!
}

type AccountPaxumPayoutMethod implements IAccountPayoutMethod {
  """The email linked to the paxum payout method."""
  email: String!

  """The ID linked to this payout method."""
  id: ID!
}

union AccountPayoutMethod = AccountPaxumPayoutMethod

type AccountSavedPaymentMethod {
  """The account linked to this saved payment method."""
  account: Account!

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """An ID to uniquely identify this payment method."""
  id: ID!

  """The payment method."""
  paymentMethod: PaymentMethod!

  """When this payment method was last updated."""
  updatedAt: Time!
}

"""Connection of the account saved payment method"""
type AccountSavedPaymentMethodConnection {
  edges: [AccountSavedPaymentMethodEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account saved payment method"""
type AccountSavedPaymentMethodEdge {
  cursor: String!
  node: AccountSavedPaymentMethod!
}

"""Session belonging to a specific account"""
type AccountSession implements Node {
  """When the session was created"""
  created: Time!

  """
  If the session belongs to the currently authenticated account. This means that
  the session cannot be revoked (or else we get weird stuff)
  """
  current: Boolean!

  """The originating user agent device"""
  device: String!

  """ID of the session"""
  id: ID!

  """The original IP"""
  ip: String!

  """When the session was last seen (last API call)"""
  lastSeen: Time!

  """Where the session was originally created"""
  location: Location!
}

"""Edge of the account session"""
type AccountSessionConnection {
  edges: [AccountSessionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the account session"""
type AccountSessionEdge {
  cursor: String!
  node: AccountSession!
}

"""Properties by which accounts connections can be sorted."""
enum AccountsSort {
  """Accounts by newest first"""
  NEW
}

"""
A transaction item.

All transactions start off in the "PAYMENT" type.

Once a transaction is refunded once, it turns into a REFUND transaction + an event is added.

If a transaction is charged back, it turns into a CHARGEBACK transaction + an event is added.

If a transaction is voided, it turns into a VOID transaction.
"""
type AccountTransaction implements Node {
  """
  The amount voided.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  amount: Int!

  """When the billing occurred."""
  billedAtDate: Date!

  """A ccbill transaction, if this transaction originated from ccbill."""
  ccbillTransaction: CCBillTransaction

  """
  The subscription linked to this transaction, if it's a club supporter subscription.
  """
  clubSupporterSubscription: AccountClubSupporterSubscription

  """When this transaction occurred."""
  createdAt: Time!

  """The currency voided in."""
  currency: Currency!

  """
  The events for this transaction.
  
  If the transaction was refunded, an event will show up with the refund amount.
  
  If the transaction was charged back, an event will show up with the chargeback amount.
  """
  events: [AccountTransactionEvent!]!

  """An ID to uniquely identify this transaction history."""
  id: ID!

  """The next billing date for this transaction, if its a subscription."""
  nextBillingDate: Date

  """The payment method linked to this transaction."""
  paymentMethod: PaymentMethod!

  """A reference, used to look up this transaction."""
  reference: String!

  """The total amount refunded, if any."""
  totalRefunded: Int!

  """The type of account transaction history, or what it belongs to."""
  type: AccountTransactionType!
}

"""Connection of the account transaction."""
type AccountTransactionConnection {
  edges: [AccountTransactionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the the account transaction."""
type AccountTransactionEdge {
  cursor: String!
  node: AccountTransaction!
}

type AccountTransactionEvent {
  """The amount."""
  amount: Int!

  """When this event occurred."""
  createdAt: Time!

  """The currency."""
  currency: Currency!

  """An ID to uniquely identify account transaction."""
  id: ID!

  """The reason for this event."""
  reason: String!
}

enum AccountTransactionType {
  CHARGEBACK
  PAYMENT
  REFUND
  VOID
}

"""Add an email to the account"""
input AddAccountEmailInput {
  """The email that should be added to this account"""
  email: String!
}

"""Email to add the account"""
type AddAccountEmailPayload {
  """The account email that was added to"""
  accountEmail: AccountEmail

  """Any validation errors from the backend"""
  validation: AddAccountEmailValidation
}

"""Validation message for adding account email"""
enum AddAccountEmailValidation {
  INVALID_EMAIL
}

"""Update category."""
input AddCategoryAlternativeTitleInput {
  """The category to update"""
  id: ID!

  """The localization for this title"""
  locale: BCP47!

  """
  The title to add.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating category"""
type AddCategoryAlternativeTitlePayload {
  """The category after update"""
  category: Category
}

"""Add alias slug."""
input AddClubSlugAliasInput {
  """The club to update"""
  id: ID!

  """
  The chosen slug for the club.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!
}

"""Payload for a new alt slug"""
type AddClubSlugAliasPayload {
  """The club after update"""
  club: Club

  """Validation for adding a new club"""
  validation: AddClubSlugAliasValidation
}

"""Validation for adding a new slug to a club"""
enum AddClubSlugAliasValidation {
  SLUG_TAKEN
}

"""Add moderator to posts queue."""
input AddModeratorToPostQueueInput {
  """The moderator account to take the action on"""
  accountId: ID!
}

"""Remove moderator from posts queue."""
type AddModeratorToPostQueuePayload {
  """The account that was updated"""
  account: Account
}

"""Add post content."""
input AddPostContentInput {
  """Image IDs for the content"""
  content: [String!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type AddPostContentPayload {
  """The post after the update"""
  post: Post
}

"""Approve the pending post input"""
input ApprovePostInput {
  """Pending post to take action against"""
  postId: ID!
}

"""Approve the pending post payload"""
type ApprovePostPayload {
  """The resulting post"""
  post: Post
}

"""Archive post."""
input ArchivePostInput {
  """The post to archive"""
  id: ID!
}

"""Payload for archiving a post"""
type ArchivePostPayload {
  """The archived post."""
  post: Post
}

"""Input to assign account to a arist role"""
input AssignAccountArtistRole {
  """The account ID that the role needs to be assigned to"""
  accountId: ID!
}

"""Assigned account"""
type AssignAccountArtistRolePayload {
  """The account that the role was assigned to"""
  account: Account
}

"""Input to assign account to a moderator role"""
input AssignAccountModeratorRole {
  """The account ID that the role needs to be assigned to"""
  accountId: ID!
}

"""Assigned account"""
type AssignAccountModeratorRolePayload {
  """The account that the role was assigned to"""
  account: Account
}

"""Input to assign account to a staff role"""
input AssignAccountStaffRole {
  """The account ID that the role needs to be assigned to"""
  accountId: ID!
}

"""Assigned account"""
type AssignAccountStaffRolePayload {
  """The account that the role was assigned to"""
  account: Account
}

type Audience implements Node {
  """A URL pointing to the object's banner."""
  banner: Resource

  """An ID pointing to this audience."""
  id: ID!

  """Posts belonging to this audience"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """
  An ID that can be used to uniquely-identify this audience. Never changes.
  """
  reference: String!

  """A url-friendly ID. Should be used when searching."""
  slug: String!

  """If this audience is standard or not."""
  standard: Boolean!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """
  A title for this audience.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  title(locale: BCP47): String!

  """All translations for this title."""
  titleTranslations: [Translation!]!

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type AudienceConnection {
  edges: [AudienceEdge!]!
  pageInfo: PageInfo!
}

type AudienceCurationProfile {
  """Audiences selected for this section."""
  audiences: [Audience!]!

  """Whether or not the audience section was completed."""
  completed: Boolean!

  """Whether or not the audience section was skipped."""
  skipped: Boolean!
}

type AudienceEdge {
  cursor: String!
  node: Audience!
}

"""Properties by which audience connections can be sorted."""
enum AudiencesSort {
  """Audience by newest first"""
  NEW

  """Audience by most posts"""
  POPULAR

  """Audience by top likes"""
  TOP
}

"""Authentication token. Used for logging in."""
type AuthenticationToken {
  """Once the token is verified, you can see the status of the account."""
  accountStatus: AuthenticationTokenAccountStatus

  """Unique ID of the token"""
  id: ID!

  """The location where this token was created at."""
  location: Location!

  """
  When the token is viewed with the correct ID, whether or not the devices match
  (you cannot use the token unless the device is the same).
  """
  sameDevice: Boolean!

  """
  Whether or not this token is "secure"
  Secure means that the token has been viewed from the same network as originally created
  if it wasn't viewed in the same network, the interface should take care and double-check with
  the user that they want to verify the token.
  """
  secure: Boolean!

  """Token belong to this authentication token"""
  token: String!

  """The userAgent this token was created from."""
  userAgent: String!

  """
  Whether or not the token is verified (required in order to see account status,
  and to use it for completing the auth flow).
  """
  verified: Boolean!
}

type AuthenticationTokenAccountStatus {
  """If multi-factor is enabled for this account"""
  multiFactor: MultiFactor

  """
  When verified, whether or not there is an account belonging to this token.
  """
  registered: Boolean!
}

"""
A balance item.

Represents balance on a specific club.
"""
type Balance {
  """The amount on this balance."""
  amount: Int!

  """The currency the balance is in."""
  currency: Currency!

  """When the balance was last updated."""
  updatedAt: Time
}

"""Localization formatted in BCP47."""
scalar BCP47

"""Become club supporter with saved payment method."""
input BecomeClubSupporterWithAccountSavedPaymentMethodInput {
  """The chosen club ID."""
  clubId: ID!

  """The chosen currency."""
  currency: Currency!

  """The chosen saved payment method."""
  savedPaymentMethodId: ID!
}

"""Payload for a new club supporter"""
type BecomeClubSupporterWithAccountSavedPaymentMethodPayload {
  """
  CCBill Transaction Token, if this was a ccbill transaction. Used to query more details about this transaction.
  """
  ccbillTransactionToken: String
}

"""Represents a billing address."""
type BillingAddress {
  addressLine1: String!
  city: String!
  country: String!
  postalCode: String!
  state: String!
}

"""Represents a billing contact."""
type BillingContact {
  email: String!
  firstName: String!
  lastName: String!
  phoneNumber: String!
}

"""Cancel account club supporter subscription input."""
input CancelAccountClubSupporterSubscriptionInput {
  """The cancellation reason for this subscription."""
  cancellationReasonId: ID!

  """The chosen club supporter subscription id."""
  clubSupporterSubscriptionId: ID!
}

"""Payload for cancelling the account club supporter."""
type CancelAccountClubSupporterSubscriptionPayload {
  """The new subscription."""
  clubSupporterSubscription: AccountClubSupporterSubscription
}

"""Input for cancelling an account deletion."""
input CancelAccountDeletionInput {
  """The account to cancel deletion."""
  accountID: ID!
}

"""Payload for cancelling an account deletion."""
type CancelAccountDeletionPayload {
  """Account that was cancelled for deletion."""
  account: Account
}

"""Cancel all active subscriptions for a club."""
input CancelActiveSupporterSubscriptionsForClubInput {
  """The id of the club."""
  clubId: ID!
}

"""Payload for cancelling all active subscriptions."""
type CancelActiveSupporterSubscriptionsForClubPayload {
  """The club."""
  club: Club
}

"""Cancel a specific payout."""
input CancelClubPayoutInput {
  """The payout to cancel."""
  payoutId: ID!
}

"""Payload for cancelling the payout."""
type CancelClubPayoutPayload {
  """The updated club payout."""
  clubPayout: ClubPayout
}

"""Cancellation reason."""
type CancellationReason implements Node {
  """If this reason is deprecated."""
  deprecated: Boolean!

  """ID of the reason."""
  id: ID!

  """Reference of the reason. Should be used for single lookups."""
  reference: String!

  """The title for this reason."""
  title(locale: BCP47): String!

  """All translations for this title."""
  titleTranslations: [Translation!]!
}

"""Connection of the reason"""
type CancellationReasonConnection {
  edges: [CancellationReasonEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the reason"""
type CancellationReasonEdge {
  cursor: String!
  node: CancellationReason!
}

"""Represents a card."""
type Card {
  """The expiration date."""
  expiration: String!

  """Last 4 digits of the card."""
  last4: String!

  """The type of card."""
  type: CardType!
}

enum CardType {
  AMEX
  DISCOVER
  JCB
  MASTERCARD
  OTHER
  VISA
}

"""Properties by which categories connections can be sorted."""
enum CategoriesSort {
  """Categories by newest first"""
  NEW

  """Categories by most posts"""
  POPULAR

  """Categories by top likes"""
  TOP
}

type Category implements Node {
  """Alternative titles for this category."""
  alternativeTitles: [Translation!]!

  """A URL pointing to the object's banner."""
  banner: Resource

  """An ID pointing to this category."""
  id: ID!

  """Posts belonging to this category"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """
  An ID that can be used to uniquely-identify this category. Never changes.
  """
  reference: String!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """
  A title for this category.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  title(locale: BCP47): String!

  """All translations for this title."""
  titleTranslations: [Translation!]!

  """The topic linked this category. If no topic is linked, field is null."""
  topic: Topic

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type CategoryConnection {
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
}

type CategoryCurationProfile {
  """Categories selected for this section."""
  categories: [Category!]!

  """Whether or not the category section was completed."""
  completed: Boolean!

  """Whether or not the category section was skipped."""
  skipped: Boolean!
}

type CategoryEdge {
  cursor: String!
  node: Category!
}

enum CCBillDeclineError {
  CARD_EXPIRED
  GENERAL_SYSTEM_ERROR
  INSUFFICIENT_FUNDS
  RATE_LIMIT_ERROR
  TRANSACTION_APPROVAL_REQUIRED
  TRANSACTION_DECLINED
  TRANSACTION_DENIED_OR_REFUSED_BY_BANK
}

"""
The ccbill subscription details.

When this object is present, this means that it can only be updated through CCBill support. https://support.ccbill.com/

For example: active subscriptions' payment methods can only be updated through support, or any saved payment methods.
"""
type CCBillSubscription {
  """The identifier for this subscription."""
  ccbillSubscriptionId: String!

  """The email belonging to this subscription."""
  email: String!

  """A link to modify the subscription."""
  link: URI!

  """The payment method belonging to this subscription."""
  paymentMethod: String!
}

type CCBillSubscriptionDetails {
  """The account linked to this ccbill subscription."""
  account: Account!
  accountingCurrency: Currency!

  """Accounting details."""
  accountingInitialPrice: Int!
  accountingRecurringPrice: Int!
  billedCurrency: Currency!

  """Billed details."""
  billedInitialPrice: Int!
  billedRecurringPrice: Int!

  """If this subscription was cancelled, the date it occurred."""
  cancelDate: Time

  """The amount of chargebacks issued."""
  chargebacksIssued: Int!

  """The club linked to this ccbill subscription, if there is one."""
  club: Club

  """If this subscription was cancelled, the expiration date."""
  expirationDate: Time

  """The ID of the subscription."""
  id: ID!

  """Whether or not this subscription was a duplicate."""
  isDuplicate: Boolean!

  """Whether or not this is recurring, or a one-time charge."""
  isRecurring: Boolean!

  """Payment method linked to this CCBill subscription."""
  paymentMethod: PaymentMethod!

  """The amount of refunds issued."""
  refundsIssued: Int!

  """The signup date."""
  signupDate: Time!

  """The status of the CCBill subscription."""
  status: CCBillSubscriptionStatus!
  subscriptionCurrency: Currency!

  """Subscription details."""
  subscriptionInitialPrice: Int!
  subscriptionRecurringPrice: Int!

  """The amount of rebills that occurred."""
  timesRebilled: Int!

  """When this subscription was updated last."""
  updatedAt: Time!

  """The amount of voids issued."""
  voidsIssued: Int!
}

enum CCBillSubscriptionStatus {
  """An active subscription that was cancelled, or a one-time charge."""
  ACTIVE_AND_CANCELLED

  """An active subscription that is not cancelled."""
  ACTIVE_AND_NOT_CANCELLED

  """An inactive subscription, i.e. expired."""
  INACTIVE
}

"""
Represents a CCBill transaction, which may or may not contain these fields.
"""
type CCBillTransaction {
  ccbillSubscriptionId: String!
  ccbillTransactionId: String
}

type CCBillTransactionDetails {
  """Whether or not the transaction was approved."""
  approved: Boolean!

  """The decline code from CCBill."""
  declineCode: String

  """The error from CCBill, if the transaction was not approved."""
  declineError: CCBillDeclineError

  """The decline text from CCBill."""
  declineText: String

  """An ID uniquely identifying this transaction."""
  id: ID!

  """
  If this transaction was approved, poll this field to until this is not null anymore.
  
  This signifies that the transaction has processed successfully (on our end),
  
  and the supporter benefits are now available.
  """
  linkedAccountClubSupporterSubscription: AccountClubSupporterSubscription
}

type Character implements Node {
  """A URL pointing to the object's banner."""
  banner: Resource

  """The club linked to this character, if it was created by a club."""
  club: Club

  """An ID pointing to this character."""
  id: ID!

  """
  A name for this character.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  name(locale: BCP47): String!

  """All translations for this name."""
  nameTranslations: [Translation!]!

  """Posts belonging to this character"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """
  An ID that can be used to uniquely-identify this character. Never changes.
  """
  reference: String!

  """The series linked to this character, if it's a series character."""
  series: Series

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type CharacterConnection {
  edges: [CharacterEdge!]!
  pageInfo: PageInfo!
}

type CharacterEdge {
  cursor: String!
  node: Character!
}

"""Properties by which character connections can be sorted."""
enum CharactersSort {
  """Characters by newest first"""
  NEW

  """Characters by most posts"""
  POPULAR

  """Characters by top likes"""
  TOP
}

type Club implements Node {
  """The current balance of this club."""
  balance: Balance!

  """A resource of the club's banner."""
  banner: Resource

  """
  Whether creating supporter-only posts is enabled or disabled for this club.
  
  When this is true, a club owner cannot mark individual content in a post as "supporter-only".
  
  Additionally, if a club owner attempts to submit a post with supporter-only
  content already present, they will not be able to.
  """
  canCreateSupporterOnlyPosts: Boolean!

  """Whether or not you can become a supporter of this club."""
  canSupport: Boolean!

  """Get or search all characters for this club."""
  characters(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the character."""
    name: String

    """Search by character slugs."""
    slugs: [String!]

    """Sorting options for characters."""
    sortBy: CharactersSort! = POPULAR
  ): CharacterConnection!

  """The total amount of characters that this club has created."""
  charactersCount: Int!

  """Whether or not characters are enabled for this club."""
  charactersEnabled: Boolean!

  """The amount of characters that this club can create."""
  charactersLimit: Int!

  """An ID pointing to this club."""
  id: ID!

  """
  Infraction history for this club
  
  Viewable by the currently authenticated account or staff+
  """
  infractionHistory(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClubInfractionHistoryConnection!

  """Club members."""
  members(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """sorting options for club members."""
    sortBy: ClubMembersSort! = NEWEST

    """Filter by whether or not this is a supporter."""
    supporter: Boolean! = false
  ): ClubMemberConnection!

  """The total amount of members in this club."""
  membersCount: Int!

  """The total amount of members in this club, who are supporters."""
  membersIsSupporterCount: Int!

  """A name for this club."""
  name: String!

  """
  When the owner of the club needs to post the next supporter post.
  
  Usually 30 days after the next post.
  
  Nil if no supporter-only posts have been created.
  """
  nextSupporterPostTime: Time

  """The account that owns this club."""
  owner: Account!

  """All payments made to this club."""
  payments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of the payment."""
    status: [ClubPaymentStatus!]
  ): ClubPaymentConnection!

  """All payouts that are scheduled or created for this club."""
  payouts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of the payout."""
    status: [ClubPayoutStatus!]
  ): ClubPayoutConnection!

  """
  The current balance of this club, representing the pending amount instead of the real amount.
  """
  pendingBalance: Balance!

  """This club's platform fee for each payment."""
  platformFee: ClubPlatformFee!

  """Posts belonging to this club"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """An internal reference, uniquely identifying the club."""
  reference: String!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """
  An alias list of slugs. These are valid, as in, you can find the club using
  the slug. However, it should always be replaced by the default slug.
  """
  slugAliases: [ClubSlugAlias!]!

  """Maximum amount of slug aliases that can be created for this club."""
  slugAliasesLimit: Int!

  """A supporter subscription price for this club."""
  supporterSubscriptionPrice: LocalizedPricingPoint!

  """Club supporter subscriptions linked to this club."""
  supporterSubscriptions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of account club supporter subscription status."""
    status: [AccountClubSupporterSubscriptionStatus!]
  ): AccountClubSupporterSubscriptionConnection!

  """Whether or not this club is suspended."""
  suspension: ClubSuspension

  """
  Club Suspension Logs.
  
  Can see who a club was suspended by, the reason and who unsuspended a particular club.
  """
  suspensionLogs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClubSuspensionLogConnection!

  """Whether or not this club is terminated."""
  termination: ClubTermination

  """A resource of the club's thumbnail."""
  thumbnail: Resource

  """Month-by-month transaction metrics of this club."""
  transactionMetrics(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClubTransactionMetricConnection!

  """Whether or not the viewer is the owner of the club."""
  viewerIsOwner: Boolean!

  """Whether or not the viewer is a member of this club."""
  viewerMember: ClubMember
}

type ClubConnection {
  edges: [ClubEdge!]!
  pageInfo: PageInfo!
}

type ClubEdge {
  cursor: String!
  node: Club!
}

"""Infraction history belonging to a club"""
type ClubInfractionHistory implements Node {
  """The club belonging to this history object."""
  club: Club!

  """
  When this infraction expires (no longer considered when issuing future infractions).
  """
  expiresAt: Time!

  """ID of the infraction history"""
  id: ID!

  """When this infraction was issued."""
  issuedAt: Time!

  """The account that issued this infraction."""
  issuerAccount: Account!

  """The rule cited for this infraction."""
  rule: Rule!

  """The source for this infraction."""
  source: ClubInfractionHistorySource!
}

"""Connection of the infraction history"""
type ClubInfractionHistoryConnection {
  edges: [ClubInfractionHistoryEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the infraction history"""
type ClubInfractionHistoryEdge {
  cursor: String!
  node: ClubInfractionHistory!
}

enum ClubInfractionHistorySource {
  MANUAL
  POST_MANUAL_REMOVAL
  POST_MODERATION_REJECTION
}

type ClubIssuedSuspensionLog {
  """
  The account that created this suspension.
  
  If nil, the suspension was created automatically
  """
  account: Account

  """The ID linked to this suspension log."""
  id: ID!

  """The reason this suspension was issued."""
  reason: ClubSuspensionReason!

  """How long the club was suspended until."""
  suspendedUntil: Time!
}

type ClubMember implements Node {
  """The account that belongs to this membership."""
  account: Account!

  """The club that this membership belongs to."""
  club: Club!

  """
  The subscription linked to this club member.
  
  Note that an account can have multiple subscriptions for the same club, due to
  the fact that we keep expired subscriptions.
  
  So this will just grab the most recent active subscription for this club.
  """
  clubSupporterSubscription: AccountClubSupporterSubscription

  """An ID pointing to this club member."""
  id: ID!

  """Whether or not this member is a supporter."""
  isSupporter: Boolean!

  """When the membership was created (when the account originally joined)."""
  joinedAt: Time!

  """If is a supporter, when they became a supporter."""
  supporterSince: Time
}

type ClubMemberConnection {
  edges: [ClubMemberEdge!]!
  pageInfo: PageInfo!
}

type ClubMemberEdge {
  cursor: String!
  node: ClubMember!
}

"""Properties by which club member connections can be sorted."""
enum ClubMembersSort {
  """By oldest members"""
  NEWEST
}

"""
A club payment item.

Represents a payment that is going to be made to a club.
"""
type ClubPayment implements Node {
  """The account transaction linked to this payment."""
  accountTransaction: AccountTransaction!

  """The base amount this payment was originally made in."""
  baseAmount: Int!

  """When this payment was created."""
  createdAt: Time!

  """The currency this payment was made in."""
  currency: Currency!

  """The club this payment is made to."""
  destinationClub: Club!

  """The final amount that will actually be paid to a club."""
  finalAmount: Int!

  """An ID to uniquely identify this club payment."""
  id: ID!

  """
  If this payment is a deduction, usually the source being a refund, chargeback or a void.
  """
  isDeduction: Boolean!

  """The amount taken off with a platform fee."""
  platformFeeAmount: Int!

  """A reference, used to look up this payment."""
  reference: String!

  """
  If this payment is in "pending" status, this will be the date when the payment becomes "ready".
  """
  settlementDate: Date!

  """The source of the payment."""
  source: ClubPaymentSource!

  """The account that made this payment."""
  sourceAccount: Account!

  """The status of the payment."""
  status: ClubPaymentStatus!
}

"""Connection of the club payment."""
type ClubPaymentConnection {
  edges: [ClubPaymentEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the the club payment."""
type ClubPaymentEdge {
  cursor: String!
  node: ClubPayment!
}

enum ClubPaymentSource {
  CLUB_SUPPORTER_SUBSCRIPTION
}

"""The status of a payment."""
enum ClubPaymentStatus {
  """
  A payment was successfully deposited as part of a payout and is no longer needed.
  """
  COMPLETE

  """A payment is pending until settled (reached "settlement date")."""
  PENDING

  """
  A payment is ready to be picked up as part of a payout.
  
  Note that a payment can be picked up by multiple payouts, it will only transition to the complete state once
  the minimum threshold for the payout has been reached. If the payout threshold
  isn't reached, the payment will be picked up
  by the next scheduled payout.
  """
  READY
}

"""
A club payout item.

Represents a payout that is going to be paid to a specific account.
"""
type ClubPayout implements Node {
  """The amount this payout is created in."""
  amount: Int!

  """The club linked to this payout."""
  club: Club!

  """The amount that will be covered as the cover fee."""
  coverFeeAmount: Int!

  """When this payout was created."""
  createdAt: Time!

  """The currency this payout is in."""
  currency: Currency!

  """When the deposit will actually attempt to occur."""
  depositDate: Time!

  """If a payout failed, an event will be created here."""
  events: [ClubPayoutEvent!]!

  """An ID to uniquely identify this club payout."""
  id: ID!

  """All payments linked to this payout."""
  payments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of the payment."""
    status: [ClubPaymentStatus!]
  ): ClubPaymentConnection!

  """The account that is going to be paid out with this payout."""
  payoutAccount: Account!

  """A reference, used to look up this payout."""
  reference: String!

  """The status of the payout."""
  status: ClubPayoutStatus!

  """The amount, with the cover fee."""
  totalAmount: Int!
}

"""Connection of the club payout."""
type ClubPayoutConnection {
  edges: [ClubPayoutEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the the club payout."""
type ClubPayoutEdge {
  cursor: String!
  node: ClubPayout!
}

type ClubPayoutEvent {
  """When this event occurred."""
  createdAt: Time!

  """The error that occurred."""
  error: String!

  """An ID to uniquely identify this club payout event."""
  id: ID!
}

"""The status of the payout."""
enum ClubPayoutStatus {
  """The payout was cancelled."""
  CANCELLED

  """The payout was successfully deposited in the target account."""
  DEPOSITED

  """
  The payout failed. A payout will try up to 3 times before this state is created.
  """
  FAILED

  """
  The "deposit date" was reached. The payout can no longer be cancelled, and will start to perform the payout.
  """
  PROCESSING

  """
  Payout is queued until the "deposit date". Payout is able to be cancelled while in this state.
  """
  QUEUED
}

"""Platform fee for a specific club."""
type ClubPlatformFee {
  """An ID to uniquely identify this club platform fee."""
  id: ID!

  """The percent of the club platform fee."""
  percent: Int!
}

type ClubRemovedSuspensionLog {
  """The account that removed this suspension."""
  account: Account!

  """The ID linked to this suspension log."""
  id: ID!
}

"""The club slug alias"""
type ClubSlugAlias {
  """The slug alias"""
  slug: String!
}

"""Properties by which club connections can be sorted."""
enum ClubsSort {
  """Clubs by popularity"""
  POPULAR
}

type ClubSuspension {
  """When the suspension expires. Can call UnSuspendClub when time = now."""
  expires: Time!
}

union ClubSuspensionLog = ClubIssuedSuspensionLog | ClubRemovedSuspensionLog

type ClubSuspensionLogConnection {
  edges: [ClubSuspensionLogEdge!]!
  pageInfo: PageInfo!
}

type ClubSuspensionLogEdge {
  cursor: String!
  node: ClubSuspensionLog!
}

"""Reasons a club suspension was created."""
enum ClubSuspensionReason {
  """Suspension was issued manually."""
  MANUAL

  """Suspension was issued from a post moderation queue."""
  POST_MODERATION_QUEUE

  """Suspension was issued from a post removal."""
  POST_REMOVAL
}

type ClubTermination {
  """The account that terminated the club."""
  account: Account!
}

type ClubTransactionMetric {
  """All of the chargebacks in money amount."""
  chargebacksAmount: Int!

  """The chargeback ratio for this month - for the amount."""
  chargebacksAmountRatio: Float!

  """How many chargebacks were issued for this month."""
  chargebacksCount: Int!

  """The chargeback ratio for this month - for the count."""
  chargebacksCountRatio: Float!

  """The currency that this metric is in."""
  currency: Currency!

  """The month that this metric represents for this club."""
  month: Int!

  """All of the refunds in money amount."""
  refundsAmount: Int!

  """The refund ratio for this month - for the amount."""
  refundsAmountRatio: Float!

  """How many refunds were issued for this month."""
  refundsCount: Int!

  """The refund ratio for this month - for the count."""
  refundsCountRatio: Float!

  """Total transaction in money amount."""
  totalTransactionsAmount: Int!

  """How many transactions were created for this month."""
  totalTransactionsCount: Int!

  """The year that this metric represents for this club."""
  year: Int!
}

"""Connection of the club metric"""
type ClubTransactionMetricConnection {
  edges: [ClubTransactionMetricEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the club metric"""
type ClubTransactionMetricEdge {
  cursor: String!
  node: ClubTransactionMetric!
}

"""Input for confirming the account email"""
input ConfirmAccountEmailInput {
  """The ID that is sent for confirmation"""
  id: String!

  """The secret for email confirmation."""
  secret: String!
}

"""Payload for confirming the account email"""
type ConfirmAccountEmailPayload {
  """The account email that was confirmed"""
  accountEmail: AccountEmail

  """Validation for confirming account email"""
  validation: ConfirmAccountEmailValidation
}

"""Validation for confirming account email"""
enum ConfirmAccountEmailValidation {
  EMAIL_TAKEN
  TOKEN_EXPIRED
}

"""A country instance."""
type Country {
  """The alpha3 code for this country."""
  alpha3: String!

  """The emoji representation of this country's flag."""
  emoji: String!

  """An ID to uniquely identify this country."""
  id: ID!

  """The full name of this country."""
  name: String!

  """
  Payout methods supported for this country.
  
  If empty, this country does not support any sort of payout.
  """
  payoutMethods: [PayoutMethod!]!
}

"""Payload for creating an account with authentication token"""
input CreateAccountWithAuthenticationTokenInput {
  """The original token"""
  token: String!

  """
  The username to create the account with.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  username: String!
}

"""Payload for creating an account"""
type CreateAccountWithAuthenticationTokenPayload {
  """The account that was created"""
  account: Account

  """A token is revoked once an account is created, this represents it"""
  revokedAuthenticationTokenId: ID!

  """Validation for creating an account"""
  validation: CreateAccountWithAuthenticationTokenValidation
}

"""Validation for creating an account with an authentication token"""
enum CreateAccountWithAuthenticationTokenValidation {
  EMAIL_TAKEN
  TOKEN_INVALID
  USERNAME_TAKEN
}

"""Create a new audience."""
input CreateAudienceInput {
  """
  The chosen slug for the audience.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!

  """If the audience is standard or not."""
  standard: Boolean!

  """
  The chosen title for the audience.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for a new audience"""
type CreateAudiencePayload {
  """The audience after creation"""
  audience: Audience

  """Validation for creating a new audience"""
  validation: CreateAudienceValidation
}

"""Validation for creating a new audience"""
enum CreateAudienceValidation {
  SLUG_TAKEN
}

"""Create a new cancellation reason input."""
input CreateCancellationReasonInput {
  """The title."""
  title: String!
}

"""Updated cancellation reason."""
type CreateCancellationReasonPayload {
  """The updated cancellation reason."""
  cancellationReason: CancellationReason
}

"""Create a new category."""
input CreateCategoryInput {
  """
  The chosen slug for the category.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!

  """
  The chosen title for the category.
  
  Validation: Max 25 characters.
  """
  title: String!

  """Optionally assign a topic to this category."""
  topicId: ID
}

"""Payload for a new category"""
type CreateCategoryPayload {
  """The category after creation"""
  category: Category

  """Validation for creating a new category"""
  validation: CreateCategoryValidation
}

"""Validation for creating a new category"""
enum CreateCategoryValidation {
  SLUG_TAKEN
}

"""Create a new character."""
input CreateCharacterInput {
  """The chosen club for the character."""
  clubId: ID

  """
  The chosen name for the character.
  
  Validation: Max 25 characters.
  """
  name: String!

  """The chosen series for the character."""
  seriesId: ID

  """
  The chosen slug for the character.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!
}

"""Payload for a new character"""
type CreateCharacterPayload {
  """The character after creation"""
  character: Character

  """Validation for creating a new character"""
  validation: CreateCharacterValidation
}

"""Validation for creating a new character"""
enum CreateCharacterValidation {
  SLUG_TAKEN
}

"""Create club."""
input CreateClubInput {
  """
  The chosen name for the club.
  
  Validation: Max 25 characters.
  """
  name: String!

  """
  The chosen slug for the club.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!
}

"""Payload for a new club"""
type CreateClubPayload {
  """The club after creation"""
  club: Club

  """Validation for creating a new club"""
  validation: CreateClubValidation
}

"""Validation for creating a new club"""
enum CreateClubValidation {
  SLUG_TAKEN
}

"""Create a new post. A club ID is required."""
input CreatePostInput {
  """The club ID that this post will belong to"""
  clubId: ID!
}

"""Payload for a created pending post"""
type CreatePostPayload {
  """The pending post after the creation"""
  post: Post
}

"""Create a new rule input."""
input CreateRuleInput {
  """
  The description.
  
  Validation: Max 25 characters. Markdown allowed.
  """
  description: String!

  """If breaking this rule would cause an infraction."""
  infraction: Boolean!

  """
  The title.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Updated rule."""
type CreateRulePayload {
  """The updated rule."""
  rule: Rule
}

"""Create a new series."""
input CreateSeriesInput {
  """
  The chosen slug for the series.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!

  """
  The chosen title for the series.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for a new series"""
type CreateSeriesPayload {
  """The series after creation"""
  series: Series

  """Validation for creating a new series"""
  validation: CreateSeriesValidation
}

"""Validation for creating a new series"""
enum CreateSeriesValidation {
  SLUG_TAKEN
}

"""Create a new topic."""
input CreateTopicInput {
  """
  The chosen description for the topic.
  
  Validation: Markdown allowed.
  """
  description: String!

  """
  The chosen slug for the topic.
  
  Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
  """
  slug: String!

  """
  The chosen title for the topic.
  
  Validation: Max 25 characters.
  """
  title: String!

  """The assigned weight for this topic."""
  weight: Int!
}

"""Payload for a new topic"""
type CreateTopicPayload {
  """The topic after creation"""
  topic: Topic

  """Validation for creating a new topic"""
  validation: CreateTopicValidation
}

"""Validation for creating a new topic"""
enum CreateTopicValidation {
  SLUG_TAKEN
}

type CurationProfile {
  """The audience profile."""
  audience: AudienceCurationProfile!

  """The category profile."""
  category: CategoryCurationProfile!

  """If the whole profile was completed or not."""
  completed: Boolean!

  """The date of birth profile."""
  dateOfBirth: DateOfBirthCurationProfile!

  """An ID uniquely identifying this profile."""
  id: ID!
}

enum Currency {
  AUD
  CAD
  EUR
  GBP
  JPY
  USD
}

scalar Date

type DateOfBirthCurationProfile {
  """Whether or not the date of birth section was completed."""
  completed: Boolean!

  """The date of birth set."""
  dateOfBirth: Time

  """Whether or not the date of birth section was skipped."""
  skipped: Boolean!
}

"""Input for removing an email from an account"""
input DeleteAccountEmailInput {
  """The email that should be removed"""
  accountEmailId: ID!
}

"""Email to add the account"""
type DeleteAccountEmailPayload {
  """The ID of the account email that was removed"""
  accountEmailId: ID!
}

"""Input for deleting an account."""
input DeleteAccountInput {
  """The account to delete."""
  accountID: ID!
}

"""Payload for the delete account"""
type DeleteAccountPayload {
  """Account that was deleted"""
  account: Account
}

"""Delete a specific account payout method."""
input DeleteAccountPayoutMethodInput {
  """The payout method to delete."""
  payoutMethodId: ID!
}

"""Payload for deleting the account payout method."""
type DeleteAccountPayoutMethodPayload {
  """The deleted account payout method."""
  deletedAccountPayoutMethodId: ID!
}

"""Delete an account saved payment method input."""
input DeleteAccountSavedPaymentMethodInput {
  """The chosen saved payment method id."""
  savedPaymentMethodId: ID!
}

"""Payload for deleting an account saved payment method."""
type DeleteAccountSavedPaymentMethodPayload {
  """The deleted saved payment method."""
  deletedAccountSavedPaymentMethodId: ID!
}

"""Delete post."""
input DeletePostInput {
  """The post to delete"""
  id: ID!
}

"""Payload for deleting a post"""
type DeletePostPayload {
  """The deleted post."""
  postId: ID
}

"""
A deposit request.

Basically, when payouts are scheduled at the beginning of the month,
a deposit request is created to tell us how much money we need our payout methods to have in order
to process all of the payouts
"""
type DepositRequest implements Node {
  """The base amount of the deposit."""
  baseAmount: Int!

  """When this deposit was created."""
  createdAt: Time!

  """The currency this deposit is in."""
  currency: Currency!

  """
  To keep platform percentages accurate, we would always overpay when depositing payouts. The estimated fee
  accounts for this and ensures we always deliver the exact $ amount that the artist sees in their balance.
  """
  estimatedFeeAmount: Int!

  """An ID to uniquely identify this deposit request."""
  id: ID!

  """
  The last date the deposit, meaning the last day until the deposit should be
  made, this is when all of the payouts would be scheduled.
  """
  lastDateForDeposit: Time!

  """The type of payout method this deposit request is created for."""
  payoutMethod: PayoutMethod!

  """All payouts linked to this deposit request."""
  payouts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of the payout."""
    status: [ClubPayoutStatus!]
  ): ClubPayoutConnection!

  """A reference, used to look up this deposit request."""
  reference: String!

  """The total amount that needs to be deposited."""
  totalAmount: Int!
}

"""Connection of the deposit request."""
type DepositRequestConnection {
  edges: [DepositRequestEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the the deposit request."""
type DepositRequestEdge {
  cursor: String!
  node: DepositRequest!
}

"""Payload for disabling account multi factor"""
type DisableAccountMultiFactorPayload {
  """The account that was disabled."""
  account: Account
}

"""Disable club characters."""
input DisableClubCharactersInput {
  """The club to disable characters for."""
  clubId: ID!
}

"""Disable club characters payload."""
type DisableClubCharactersPayload {
  """The new club after disabling club characters."""
  club: Club
}

"""Disable club supporter-only posts."""
input DisableClubSupporterOnlyPostsInput {
  """The club to disable supporter-only posts for."""
  clubId: ID!
}

"""Disable club supporter-only posts payload."""
type DisableClubSupporterOnlyPostsPayload {
  """The new club after supporter-only posts are disabled."""
  club: Club
}

"""Enable club characters."""
input EnableClubCharactersInput {
  """
  The amount of characters the club will be able to create.
  
  Validation: Limit to 200.
  """
  charactersLimit: Int!

  """The club to enable club characters for."""
  clubId: ID!
}

"""Enable club characters payload."""
type EnableClubCharactersPayload {
  """The new club after enabling club characters."""
  club: Club
}

"""Enable club supporter-only posts."""
input EnableClubSupporterOnlyPostsInput {
  """The club to enable supporter-only posts for."""
  clubId: ID!
}

"""Enable club supporter-only posts payload."""
type EnableClubSupporterOnlyPostsPayload {
  """The new club after supporter-only posts are enabled."""
  club: Club
}

"""Input for enrolling the account into TOTP"""
input EnrollAccountMultiFactorTotpInput {
  """The code that the TOTP expects"""
  code: String!

  """The TOTP ID, sent initially"""
  id: String!
}

"""Payload of the enrolled totp payload"""
type EnrollAccountMultiFactorTotpPayload {
  """The account that was enrolled."""
  account: Account

  """Validation for enrolling TOTP"""
  validation: EnrollAccountMultiFactorTotpValidation
}

"""Validation for enrolling in TOTP"""
enum EnrollAccountMultiFactorTotpValidation {
  INVALID_CODE
}

"""An expired account club supporter subscription."""
type ExpiredAccountClubSupporterSubscription {
  """The account linked to this subscription."""
  account: Account!

  """When this subscription was originally cancelled."""
  cancelledAt: Time!

  """The club linked to this subscription."""
  club: Club!

  """Wen this subscription expired."""
  expiredAt: Time!

  """An ID to uniquely identify this expired subscription."""
  id: ID!

  """
  When the account first became a supporter. Note that when subscribing next
  time, this date will be kept, but subtracted by the amount of days they were
  not a supporter, and normalized to the current date.
  """
  supporterSince: Time!
}

"""Connection of the expired account club supporter subscription"""
type ExpiredAccountClubSupporterSubscriptionConnection {
  edges: [ExpiredAccountClubSupporterSubscriptionEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the expired account club supporter subscriptions"""
type ExpiredAccountClubSupporterSubscriptionEdge {
  cursor: String!
  node: ExpiredAccountClubSupporterSubscription!
}

"""Extend account club supporter subscription input."""
input ExtendAccountClubSupporterSubscriptionInput {
  """The chosen club supporter subscription id."""
  clubSupporterSubscriptionId: ID!

  """The amount of days to extend it for."""
  days: Int!
}

"""Payload for extending the account club supporter."""
type ExtendAccountClubSupporterSubscriptionPayload {
  """The new subscription."""
  clubSupporterSubscription: AccountClubSupporterSubscription
}

"""Payload of the created account recovery codes"""
type GenerateAccountMultiFactorRecoveryCodesPayload {
  """The recovery codes that were created"""
  accountMultiFactorRecoveryCodes: [AccountMultiFactorRecoveryCode!]!
}

"""Payload of the generated TOTP token"""
type GenerateAccountMultiFactorTotpPayload {
  """TOTP pair that was generated"""
  multiFactorTotp: MultiFactorTotp
}

"""Generate ccbill club supporter payment link."""
input GenerateCCBillClubSupporterPaymentLinkInput {
  """The chosen club ID."""
  clubId: ID!

  """The chosen currency."""
  currency: Currency!

  """Whether or not we want to save the payment details for later."""
  savePaymentDetailsForLater: Boolean!
}

"""Payload for a new ccbill payment link"""
type GenerateCCBillClubSupporterPaymentLinkPayload {
  """The payment link to use."""
  paymentLink: URI
}

"""Generate club supporter receipt input."""
input GenerateClubSupporterPaymentReceiptFromAccountTransactionInput {
  """The id of the transaction."""
  transactionId: ID!
}

"""Payload for generating the receipt."""
type GenerateClubSupporterPaymentReceiptFromAccountTransactionPayload {
  """The link to the receipt."""
  link: URI
}

"""Generate club supporter receipt input."""
input GenerateClubSupporterRefundReceiptFromAccountTransactionInput {
  """The id of the transaction event, since we can have multiple refunds."""
  transactionEventId: ID!

  """The id of the transaction."""
  transactionId: ID!
}

"""Payload for generating the receipt."""
type GenerateClubSupporterRefundReceiptFromAccountTransactionPayload {
  """The link to the receipt."""
  link: URI
}

"""Generate a refund amount."""
input GenerateRefundAmountForAccountTransactionInput {
  """The id of the transaction."""
  accountTransactionId: ID!
}

"""Payload for generating the receipt."""
type GenerateRefundAmountForAccountTransactionPayload {
  """The refund amount."""
  refundAmount: RefundAmount
}

"""
Payload for granting access to an account using the token and the recovery code
"""
input GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeInput {
  """Recovery code"""
  recoveryCode: String!

  """The original token"""
  token: String!
}

"""
Payload for granting access to an account using the authentication token and Recovery Code
"""
type GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodePayload {
  """The account that granted access to"""
  account: Account

  """
  A token is revoked once the account access is granted, this represents it
  """
  revokedAuthenticationTokenId: ID!

  """Validation options"""
  validation: GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeValidation
}

"""Validation for granting account access with multi factor"""
enum GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeValidation {
  RECOVERY_CODE_INVALID
  TOKEN_INVALID
}

"""
Payload for granting access to an account using the token and the totp code
"""
input GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpInput {
  """TOTP code"""
  code: String!

  """The original token"""
  token: String!
}

"""
Payload for granting access to an account using the authentication token and TOTP code
"""
type GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpPayload {
  """The account that granted access to"""
  account: Account

  """
  A token is revoked once the account access is granted, this represents it
  """
  revokedAuthenticationTokenId: ID!

  """Validation options"""
  validation: GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpValidation
}

"""Validation for granting account access with multi factor"""
enum GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpValidation {
  CODE_INVALID
  TOKEN_INVALID
}

"""
Payload for granting account access with the token. Will fail if account has multi-factor auth enabled.
"""
input GrantAccountAccessWithAuthenticationTokenInput {
  """The original token"""
  token: String!
}

type GrantAccountAccessWithAuthenticationTokenPayload {
  """The account that granted access to"""
  account: Account

  """
  A token is revoked once the account access is granted, this represents it
  """
  revokedAuthenticationTokenId: ID!

  """Validation options"""
  validation: GrantAccountAccessWithAuthenticationTokenValidation
}

enum GrantAccountAccessWithAuthenticationTokenValidation {
  TOKEN_INVALID
}

"""Input for granting an authentication token"""
input GrantAuthenticationTokenInput {
  """The email that the token will be granted for"""
  email: String!
}

"""Payload for starting an authentication"""
type GrantAuthenticationTokenPayload {
  """The authentication token after starting"""
  authenticationToken: AuthenticationToken

  """Validation for granting an authentication token"""
  validation: GrantAuthenticationTokenValidation
}

"""Validation for granting an authentication token"""
enum GrantAuthenticationTokenValidation {
  INVALID_EMAIL
}

interface IAccountClubSupporterSubscription {
  """The account linked to this subscription."""
  account: Account!

  """The billing amount."""
  billingAmount: Int!

  """The currency."""
  billingCurrency: Currency!

  """
  If a subscription is failed to be billed, it will be updated with this error object.
  """
  billingError: AccountClubSupporterSubscriptionBillingError

  """The ccbill subscription."""
  ccbillSubscription: CCBillSubscription

  """The club linked to this subscription."""
  club: Club!

  """An ID to uniquely identify this subscription."""
  id: ID!

  """A reference, used to look up this subscription."""
  reference: String!

  """When the account first became a supporter."""
  supporterSince: Time!

  """Transactions for this account."""
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """The start date for the transaction history."""
    from: Time

    """Returns the last _n_ elements from the list."""
    last: Int

    """The end date, optional (will search until end of time)."""
    to: Time

    """Filter by the type."""
    type: AccountTransactionType
  ): AccountTransactionConnection!

  """When this subscription was last updated."""
  updatedAt: Time!
}

interface IAccountPayoutMethod {
  """The ID linked to this payout method"""
  id: ID!
}

"""Initiate a payout for a specific club."""
input InitiateClubPayoutInput {
  """The club to initiate the payout for."""
  clubId: ID!

  """Optionally set the deposit date."""
  depositDate: Time
}

"""Initiate a payout for a specific club."""
type InitiateClubPayoutPayload {
  """The club that the payout was initiated for."""
  club: Club!
}

"""Issue a club infraction."""
input IssueClubInfractionInput {
  """The club to issue the infraction to."""
  clubId: ID!

  """
  Pass a custom end time. If none is passed, will use sliding scale based on previous infractions.
  """
  customEndTime: Time

  """The rule to cite."""
  ruleId: ID!
}

"""Issue a new club infraction payload."""
type IssueClubInfractionPayload {
  """The new club infraction history item."""
  clubInfractionHistory: ClubInfractionHistory
}

"""Join a club input."""
input JoinClubInput {
  """The chosen club ID."""
  clubId: ID!
}

"""Payload for a new club member"""
type JoinClubPayload {
  """The membership after creation"""
  clubMember: ClubMember
}

type Language {
  """BCP47 locale"""
  locale: BCP47!

  """Fully qualified name"""
  name: String!
}

"""Leave a club."""
input LeaveClubInput {
  """The chosen club ID."""
  clubId: ID!
}

"""Payload for leaving a club"""
type LeaveClubPayload {
  """The club membership that was removed"""
  clubMemberId: ID!
}

"""Like a post."""
input LikePostInput {
  """The post ID that you want to like"""
  id: ID!
}

"""Payload for the liked post"""
type LikePostPayload {
  """The new PostLike entry."""
  postLike: PostLike
}

"""Type describing a localized pricing point."""
type LocalizedPricingPoint {
  """Price for your current location + currency."""
  localizedPrice: Price!

  """All other prices in different currencies."""
  prices: [Price!]!
}

"""Represents a physical location."""
type Location {
  """City"""
  city: String!

  """Country"""
  country: String!

  """Latitude"""
  latitude: Float!

  """Longitude"""
  longitude: Float!

  """Postal Code"""
  postalCode: String!

  """Subdivision"""
  subdivision: String!
}

"""Input for locking an account."""
input LockAccountInput {
  """The account to lock."""
  accountID: ID!

  """When the lock should end."""
  endTime: Time!
}

"""Payload for the locked account"""
type LockAccountPayload {
  """Account that was locked"""
  account: Account
}

"""General moderator settings."""
type ModeratorSettings {
  """If this moderator is in queue."""
  isInModeratorQueue: Boolean!

  """
  The last time this moderator was selected for a post. Null if moderator not in queue
  """
  lastSelected: Time
}

"""Types of multi factor enabled for this account"""
type MultiFactor {
  totp: Boolean!
}

"""TOTP secret + image combination"""
type MultiFactorTotp {
  """The TOTP ID. Should be sent back when creating the TOTP"""
  id: String!

  """
  Always html image compatible. Just set SRC tag to this and it will work!
  """
  imageSrc: String!

  """The TOTP secret"""
  secret: String!
}

type Mutation {
  """Add an email to the account, will need to be confirmed"""
  addAccountEmail(input: AddAccountEmailInput!): AddAccountEmailPayload

  """Add an alternative title to the category."""
  addCategoryAlternativeTitle(input: AddCategoryAlternativeTitleInput!): AddCategoryAlternativeTitlePayload

  """Add an alternative slug to the club"""
  addClubSlugAlias(input: AddClubSlugAliasInput!): AddClubSlugAliasPayload

  """
  Add moderator to posts queue
  
  Moderator+ only
  """
  addModeratorToPostQueue(input: AddModeratorToPostQueueInput!): AddModeratorToPostQueuePayload

  """Update a post in draft status - add content"""
  addPostContent(input: AddPostContentInput!): AddPostContentPayload

  """
  Approve a specific post.
  
  Moderator+ only
  """
  approvePost(input: ApprovePostInput!): ApprovePostPayload

  """Archive a post, removing it from public visibility."""
  archivePost(input: ArchivePostInput!): ArchivePostPayload

  """Assign a artist role to the account"""
  assignAccountArtistRole(input: AssignAccountArtistRole!): AssignAccountArtistRolePayload

  """Assign a moderator role to the account"""
  assignAccountModeratorRole(input: AssignAccountModeratorRole!): AssignAccountModeratorRolePayload

  """Assign a staff role to the account"""
  assignAccountStaffRole(input: AssignAccountStaffRole!): AssignAccountStaffRolePayload

  """Become a club supporter using a saved payment method"""
  becomeClubSupporterWithAccountSavedPaymentMethod(input: BecomeClubSupporterWithAccountSavedPaymentMethodInput!): BecomeClubSupporterWithAccountSavedPaymentMethodPayload

  """Cancel a club supporter subscription"""
  cancelAccountClubSupporterSubscription(input: CancelAccountClubSupporterSubscriptionInput!): CancelAccountClubSupporterSubscriptionPayload

  """Cancel an account deletion."""
  cancelAccountDeletion(input: CancelAccountDeletionInput!): CancelAccountDeletionPayload

  """
  Cancel all active subscriptions for a club.
  
  Staff+ only.
  """
  cancelActiveSupporterSubscriptionsForClub(input: CancelActiveSupporterSubscriptionsForClubInput!): CancelActiveSupporterSubscriptionsForClubPayload

  """
  Cancel a specific club payout.
  
  Staff+ only.
  """
  cancelClubPayout(input: CancelClubPayoutInput!): CancelClubPayoutPayload

  """Confirm account email, so it may be used"""
  confirmAccountEmail(input: ConfirmAccountEmailInput!): ConfirmAccountEmailPayload

  """Create an account using the current authentication token"""
  createAccountWithAuthenticationToken(input: CreateAccountWithAuthenticationTokenInput!): CreateAccountWithAuthenticationTokenPayload

  """Create a new audience"""
  createAudience(input: CreateAudienceInput!): CreateAudiencePayload

  """Create a new reason."""
  createCancellationReason(input: CreateCancellationReasonInput!): CreateCancellationReasonPayload

  """Create a new category"""
  createCategory(input: CreateCategoryInput!): CreateCategoryPayload

  """
  Create a new character.
  
  Must either enter a seriesId for a series character or a clubId for a club character.
  
  If entering a SeriesId, the authorization is Staff+ only.
  If entering a ClubId, you must be the owner of the club.
  """
  createCharacter(input: CreateCharacterInput!): CreateCharacterPayload

  """Create a new club"""
  createClub(input: CreateClubInput!): CreateClubPayload

  """Create a new post"""
  createPost(input: CreatePostInput!): CreatePostPayload

  """Create a new rule."""
  createRule(input: CreateRuleInput!): CreateRulePayload

  """Create a new series"""
  createSeries(input: CreateSeriesInput!): CreateSeriesPayload

  """Create a new topic"""
  createTopic(input: CreateTopicInput!): CreateTopicPayload

  """
  Delete an account.
  
  The deletion will be scheduled and deleted after 30 days.
  
  During this time, the account will be locked. (isLocked will not be true, however, "deleting" will be available).
  """
  deleteAccount(input: DeleteAccountInput!): DeleteAccountPayload

  """
  Delete account email - email must belong to account and cannot be the primary email
  """
  deleteAccountEmail(input: DeleteAccountEmailInput!): DeleteAccountEmailPayload

  """
  Delete the current payout method linked to the logged-in account.
  
  If no payout method is set, payouts won't happen.
  """
  deleteAccountPayoutMethod(input: DeleteAccountPayoutMethodInput!): DeleteAccountPayoutMethodPayload

  """Delete an account saved payment method"""
  deleteAccountSavedPaymentMethod(input: DeleteAccountSavedPaymentMethodInput!): DeleteAccountSavedPaymentMethodPayload

  """
  Delete a post. Can only be deleted if the post is in Draft, Archived, Removed, Discarded or Rejected state.
  """
  deletePost(input: DeletePostInput!): DeletePostPayload

  """
  Disable account multi factor
  
  Will delete all multi factor settings (if TOTP is set up, etc...)
  
  Priv. users cannot disable multi factor
  """
  disableAccountMultiFactor: DisableAccountMultiFactorPayload

  """
  Disable club characters.
  
  Will disable character creation for the club.
  
  Staff+ only.
  """
  disableClubCharacters(input: DisableClubCharactersInput!): DisableClubCharactersPayload

  """
  Disable club supporter-only posts.
  
  When this mutation is ran, the club will no longer be able to create
  supporter-only posts, and their supporter timer will reset, as well as
  removing the ability to collect subscriptions.
  
  In order to be able to collect subscriptions again, the
  enableClubSupporterOnlyPosts mutation should be ran, and the club owner should
  create a post with supporter-only content.
  
  Staff+ only.
  """
  disableClubSupporterOnlyPosts(input: DisableClubSupporterOnlyPostsInput!): DisableClubSupporterOnlyPostsPayload

  """
  Enable club characters.
  
  Will enable club characters. Requires a limit to be set as well.
  
  Staff+ only.
  """
  enableClubCharacters(input: EnableClubCharactersInput!): EnableClubCharactersPayload

  """
  Enable club supporter-only posts, if previously disabled.
  
  Staff+ only.
  """
  enableClubSupporterOnlyPosts(input: EnableClubSupporterOnlyPostsInput!): EnableClubSupporterOnlyPostsPayload

  """
  Enroll into TOTP.
  
  Must have called "generateAccountMultiFactorTOTP" first before enrolling, since this will
  generate a valid secret
  """
  enrollAccountMultiFactorTotp(input: EnrollAccountMultiFactorTotpInput!): EnrollAccountMultiFactorTotpPayload

  """
  Extend an account club supporter subscription for an X amount of days, so basically delay their billing date for x days.
  
  Staff+ only.
  """
  extendAccountClubSupporterSubscription(input: ExtendAccountClubSupporterSubscriptionInput!): ExtendAccountClubSupporterSubscriptionPayload

  """
  Generates a new set of recovery codes. The previous set (whatever it was) will be deleted!
  """
  generateAccountMultiFactorRecoveryCodes: GenerateAccountMultiFactorRecoveryCodesPayload

  """
  Generate a TOTP key for the current user. Recovery codes must be generated first.
  """
  generateAccountMultiFactorTotp: GenerateAccountMultiFactorTotpPayload

  """Generate a CCBill payment link to become a club supporter"""
  generateCCBillClubSupporterPaymentLink(input: GenerateCCBillClubSupporterPaymentLinkInput!): GenerateCCBillClubSupporterPaymentLinkPayload

  """Generate a payment receipt from the account transaction."""
  generateClubSupporterPaymentReceiptFromAccountTransaction(input: GenerateClubSupporterPaymentReceiptFromAccountTransactionInput!): GenerateClubSupporterPaymentReceiptFromAccountTransactionPayload

  """Generate a refund receipt from the account transaction."""
  generateClubSupporterRefundReceiptFromAccountTransaction(input: GenerateClubSupporterRefundReceiptFromAccountTransactionInput!): GenerateClubSupporterRefundReceiptFromAccountTransactionPayload

  """
  Generate a refund amount for a transaction.
  
  Staff+ only.
  """
  generateRefundAmountForAccountTransaction(input: GenerateRefundAmountForAccountTransactionInput!): GenerateRefundAmountForAccountTransactionPayload

  """
  Grant account access with authentication token
  
  Should be used if the token does not require a multi-factor authentication step, and the token has to be
  verified first
  """
  grantAccountAccessWithAuthenticationToken(input: GrantAccountAccessWithAuthenticationTokenInput!): GrantAccountAccessWithAuthenticationTokenPayload

  """
  Grant account access using an authentication token and a multi factor option
  
  Set "recoveryCode" when authenticating with a recovery code
  """
  grantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCode(input: GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodeInput!): GrantAccountAccessWithAuthenticationTokenAndMultiFactorRecoveryCodePayload

  """
  Grant account access using an authentication token and a multi factor option
  
  Set "code" when authenticating with a TOTP code
  """
  grantAccountAccessWithAuthenticationTokenAndMultiFactorTotp(input: GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpInput!): GrantAccountAccessWithAuthenticationTokenAndMultiFactorTotpPayload

  """
  Grant authentication token
  
  Authentication token can be used to login into a specific account, provided the token's value is first redeemed
  with the query
  """
  grantAuthenticationToken(input: GrantAuthenticationTokenInput!): GrantAuthenticationTokenPayload

  """
  Initiate a club payout for the specific club.
  
  Note that only 1 payout can be created at a time, so this call will fail if
  there is a payout either "in progress" or "queued".
  
  Staff+ only.
  """
  initiateClubPayout(input: InitiateClubPayoutInput!): InitiateClubPayoutPayload

  """Issue a club infraction."""
  issueClubInfraction(input: IssueClubInfractionInput!): IssueClubInfractionPayload

  """Join the club, becoming a member."""
  joinClub(input: JoinClubInput!): JoinClubPayload

  """
  Leave the club.
  
  If you are the owner of the club, you cannot leave the club.
  """
  leaveClub(input: LeaveClubInput!): LeaveClubPayload

  """Like a post"""
  likePost(input: LikePostInput!): LikePostPayload

  """Lock an account for a specific duration."""
  lockAccount(input: LockAccountInput!): LockAccountPayload

  """
  Make the alias slug the default, swapping out the old slug into the alias list.
  """
  promoteClubSlugAliasToDefault(input: PromoteClubSlugAliasToDefaultInput!): PromoteClubSlugAliasToDefaultPayload

  """
  Issue a refund on a transaction.
  
  Staff+ only.
  """
  refundAccountTransaction(input: RefundAccountTransactionInput!): RefundAccountTransactionPayload

  """
  Reject a specific post
  
  Moderator+ only
  """
  rejectPost(input: RejectPostInput!): RejectPostPayload

  """Remove an alternative title from the category."""
  removeCategoryAlternativeTitle(input: RemoveCategoryAlternativeTitleInput!): RemoveCategoryAlternativeTitlePayload

  """
  In case of a false infraction, you can remove it from the club's history.
  
  Staff+ only.
  """
  removeClubInfractionHistory(input: RemoveClubInfractionHistoryInput!): RemoveClubInfractionHistoryPayload

  """Remove an alternative slug from the club"""
  removeClubSlugAlias(input: RemoveClubSlugAliasInput!): RemoveClubSlugAliasPayload

  """
  Remove moderator from posts queue
  
  Moderator+ only
  """
  removeModeratorFromPostQueue(input: RemoveModeratorFromPostQueueInput!): RemoveModeratorFromPostQueuePayload

  """
  Remove a specific post, after a post has already been moderated
  
  Staff+ only
  """
  removePost(input: RemovePostInput!): RemovePostPayload

  """Update a post in draft status - remove content"""
  removePostContent(input: RemovePostContentInput!): RemovePostContentPayload

  """Report a specific post"""
  reportPost(input: ReportPostInput!): ReportPostPayload

  """
  Retry a specific club payout if it's failed.
  
  Staff+ only.
  """
  retryClubPayout(input: RetryClubPayoutInput!): RetryClubPayoutPayload

  """Logout the current account"""
  revokeAccountAccess: RevokeAccountAccessPayload

  """Revoke the artist role from the account"""
  revokeAccountArtistRole(input: RevokeAccountArtistRole!): RevokeAccountArtistRolePayload

  """Revoke the moderator role from the account"""
  revokeAccountModeratorRole(input: RevokeAccountModeratorRole!): RevokeAccountModeratorRolePayload

  """Revoke a session for this account"""
  revokeAccountSession(input: RevokeAccountSessionInput!): RevokeAccountSessionPayload

  """Revoke the staff role from the account"""
  revokeAccountStaffRole(input: RevokeAccountStaffRole!): RevokeAccountStaffRolePayload

  """
  Revoke authentication token
  
  Creating accounts and completing authentication flows will not be possible once it's revoked
  """
  revokeAuthenticationToken(input: RevokeAuthenticationTokenInput!): RevokeAuthenticationTokenPayload

  """
  Set the currently logged-in account's payout method to use Paxum e-wallet.
  """
  setPaxumAccountPayoutMethod(input: SetPaxumAccountPayoutMethodInput!): SetPaxumAccountPayoutMethodPayload

  """Submit a post."""
  submitPost(input: SubmitPostInput!): SubmitPostPayload

  """
  Suspend the club.
  
  Staff+ only.
  """
  suspendClub(input: SuspendClubInput!): SuspendClubPayload

  """
  Terminate the club.
  
  Terminating a club will remove it from public visibility. Subscriptions will not be cancelled.
  
  Staff+ only.
  """
  terminateClub(input: TerminateClubInput!): TerminateClubPayload

  """Un-archive a post, putting it back in public view."""
  unArchivePost(input: UnArchivePostInput!): UnArchivePostPayload

  """
  Un-Suspend the club. Suspension must be expired.
  
  Staff+ may un-suspend even if suspension hasn't expired yet.
  """
  unSuspendClub(input: UnSuspendClubInput!): UnSuspendClubPayload

  """
  Un-Terminate the club.
  
  Un-terminating will allow the club to be viewed publicly again, but all subscriptions will remain cancelled.
  
  Staff+ only.
  """
  unTerminateClub(input: UnTerminateClubInput!): UnTerminateClubPayload

  """Undo a like on a post"""
  undoLikePost(input: UndoLikePostInput!): UndoLikePostPayload

  """
  Unlock Account - account may be locked for any reason. Use this endpoint to unlock the account.
  
  Can be unlocked by staff+ regardless if time is past.
  """
  unlockAccount(input: UnlockAccountInput!): UnlockAccountPayload

  """Update account details for the currently logged-in account."""
  updateAccountDetails(input: UpdateAccountDetailsInput!): UpdateAccountDetailsPayload

  """
  Update the account email status to primary
  
  Cannot update if the email is not confirmed
  """
  updateAccountEmailStatusToPrimary(input: UpdateAccountEmailStatusToPrimaryInput!): UpdateAccountEmailStatusToPrimaryPayload

  """
  Update the account username
  
  Will retain the old username
  """
  updateAccountUsername(input: UpdateAccountUsernameInput!): UpdateAccountUsernamePayload

  """Update audience banner"""
  updateAudienceBanner(input: UpdateAudienceBannerInput!): UpdateAudienceBannerPayload

  """Update audience standard"""
  updateAudienceIsStandard(input: UpdateAudienceIsStandardInput!): UpdateAudienceIsStandardPayload

  """Update audience thumbnail"""
  updateAudienceThumbnail(input: UpdateAudienceThumbnailInput!): UpdateAudienceThumbnailPayload

  """Update audience title"""
  updateAudienceTitle(input: UpdateAudienceTitleInput!): UpdateAudienceTitlePayload

  """Update a reason deprecation."""
  updateCancellationReasonDeprecated(input: UpdateCancellationReasonDeprecatedInput!): UpdateCancellationReasonDeprecatedPayload

  """Update a reason title."""
  updateCancellationReasonTitle(input: UpdateCancellationReasonTitleInput!): UpdateCancellationReasonTitlePayload

  """Update category thumbnail"""
  updateCategoryThumbnail(input: UpdateCategoryThumbnailInput!): UpdateCategoryThumbnailPayload

  """Update category title"""
  updateCategoryTitle(input: UpdateCategoryTitleInput!): UpdateCategoryTitlePayload

  """Update the category topic"""
  updateCategoryTopic(input: UpdateCategoryTopicInput!): UpdateCategoryTopicPayload

  """Update character title"""
  updateCharacterName(input: UpdateCharacterNameInput!): UpdateCharacterNamePayload

  """
  Update character thumbnail
  
  Note that this is Staff+ only for now - even if the character is a club character.
  """
  updateCharacterThumbnail(input: UpdateCharacterThumbnailInput!): UpdateCharacterThumbnailPayload

  """
  Set the amount of characters that a club can create.
  
  Staff+ only.
  """
  updateClubCharactersLimit(input: UpdateClubCharactersLimitInput!): UpdateClubCharactersLimitPayload

  """Update the club's name (english-only for now)."""
  updateClubName(input: UpdateClubNameInput!): UpdateClubNamePayload

  """
  Update a payout's deposit date.
  
  Can be used to either make the payout happen earlier or schedule it for the future.
  
  Setting the time to be before the current time will make the payout happen instantly.
  
  Staff+ only.
  """
  updateClubPayoutDepositDate(input: UpdateClubPayoutDepositDateInput!): UpdateClubPayoutDepositDatePayload

  """
  Update the club's platform fee.
  
  Cannot be less than 20 or more than 30 percent.
  
  Staff+ only.
  """
  updateClubPlatformFee(input: UpdateClubPlatformFeeInput!): UpdateClubPlatformFeePayload

  """Update the club thumbnail"""
  updateClubThumbnail(input: UpdateClubThumbnailInput!): UpdateClubThumbnailPayload

  """Update the audience for the curation profile"""
  updateCurationProfileAudience(input: UpdateCurationProfileAudienceInput!): UpdateCurationProfileAudiencePayload

  """Update the category for the curation profile"""
  updateCurationProfileCategory(input: UpdateCurationProfileCategoryInput!): UpdateCurationProfileCategoryPayload

  """Update the date of birth for the curation profile"""
  updateCurationProfileDateOfBirth(input: UpdateCurationProfileDateOfBirthInput!): UpdateCurationProfileDateOfBirthPayload

  """Update a post in draft status - audience"""
  updatePostAudience(input: UpdatePostAudienceInput!): UpdatePostAudiencePayload

  """Update a post in draft status - categories"""
  updatePostCategories(input: UpdatePostCategoriesInput!): UpdatePostCategoriesPayload

  """Update a post in draft status - characters"""
  updatePostCharacters(input: UpdatePostCharactersInput!): UpdatePostCharactersPayload

  """
  Update a post content - whether or not it is supporter only.
  
  If updating to true, the club must be able to post supporter-only content through "canCreateSupporterOnlyPosts"
  
  Can update to false even if "canCreateSupporterOnlyPosts" is false.
  """
  updatePostContentIsSupporterOnly(input: UpdatePostContentIsSupporterOnlyInput!): UpdatePostContentIsSupporterOnlyPayload

  """
  Update a post in draft status - update post content order - need to send exact same IDs
  """
  updatePostContentOrder(input: UpdatePostContentOrderInput!): UpdatePostContentOrderPayload

  """Update a post in draft status - description"""
  updatePostDescription(input: UpdatePostDescriptionInput!): UpdatePostDescriptionPayload

  """Update a rule deprecation."""
  updateRuleDeprecated(input: UpdateRuleDeprecatedInput!): UpdateRuleDeprecatedPayload

  """Update a rule description."""
  updateRuleDescription(input: UpdateRuleDescriptionInput!): UpdateRuleDescriptionPayload

  """Update a rule infraction."""
  updateRuleInfraction(input: UpdateRuleInfractionInput!): UpdateRuleInfractionPayload

  """Update a rule title."""
  updateRuleTitle(input: UpdateRuleTitleInput!): UpdateRuleTitlePayload

  """Update series thumbnail"""
  updateSeriesThumbnail(input: UpdateSeriesThumbnailInput!): UpdateSeriesThumbnailPayload

  """Update series title"""
  updateSeriesTitle(input: UpdateSeriesTitleInput!): UpdateSeriesTitlePayload

  """Update topic banner"""
  updateTopicBanner(input: UpdateTopicBannerInput!): UpdateTopicBannerPayload

  """Update topic description"""
  updateTopicDescription(input: UpdateTopicDescriptionInput!): UpdateTopicDescriptionPayload

  """Update topic title"""
  updateTopicTitle(input: UpdateTopicTitleInput!): UpdateTopicTitlePayload

  """Update topic weight"""
  updateTopicWeight(input: UpdateTopicWeightInput!): UpdateTopicWeightPayload

  """
  Will verify the authentication token. Requires the secret (sent in an email)
  """
  verifyAuthenticationToken(input: VerifyAuthenticationTokenInput!): VerifyAuthenticationTokenPayload
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

"""A payment method."""
type PaymentMethod {
  """Billing address of this card."""
  billingAddress: BillingAddress

  """Billing contact of this card."""
  billingContact: BillingContact

  """Card linked to this payment method."""
  card: Card!
}

enum PayoutMethod {
  PAXUM
}

type Post implements Node {
  """Represents the audience that this post belongs to"""
  audience: Audience

  """Audit logs belonging to this pending post"""
  auditLogs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostAuditLogConnection!

  """Categories that belong to this post"""
  categories: [Category!]!

  """Characters that belong to this post"""
  characters: [Character!]!

  """The club belonging to the post"""
  club: Club!

  """Content belonging to this post"""
  content: [PostContent!]!

  """The contributor who contributed this post"""
  contributor: Account!

  """The date and time of when this post was created"""
  createdAt: Time!

  """
  A description for this post.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  description(locale: BCP47): String!

  """All translations for this description."""
  descriptionTranslations: [Translation!]!
  id: ID!

  """The amount of likes on this post."""
  likes: Int!

  """The date and time of when this post was posted"""
  postedAt: Time

  """
  The reference of this post. Should always be used to reference this post.
  """
  reference: String!

  """Reports belonging to a post"""
  reports(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """From which date the post reports should be shown."""
    from: Time!

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    The end date of the post reports. Optional - if not specified, will search through all-time.
    """
    to: Time
  ): PostReportConnection!

  """
  If this post was removed or rejected from the moderator queue, you can view the rule that was cited.
  """
  rule: Rule

  """The state of the post."""
  state: PostState!

  """Suggested posts for this post."""
  suggestedPosts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostConnection!

  """The supporter-only status."""
  supporterOnlyStatus: SupporterOnlyStatus!

  """Whether or not the viewer liked this post."""
  viewerLiked: PostLike

  """Whether or not the post was reported by the viewer."""
  viewerReport: PostReport
}

"""
Post audit log

Audit log is created when a moderator takes an action against a pending post
"""
type PostAuditLog implements Node {
  """The status or the action that was taken against the pending post"""
  action: PostAuditLogAction!

  """ID of the audit log"""
  id: ID!

  """The moderator that this log belongs to"""
  moderator: Account!

  """Additional notes by the moderator"""
  notes: String

  """The post linked to this audit log"""
  post: Post!

  """If a post was removed or rejected, this is the rule that was cited."""
  rule: Rule
}

enum PostAuditLogAction {
  APPROVED
  DENIED
  REMOVED
}

"""Connection of the audit log"""
type PostAuditLogConnection {
  edges: [PostAuditLogEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the audit log"""
type PostAuditLogEdge {
  cursor: String!
  node: PostAuditLog!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

"""Represents content for a post."""
type PostContent {
  """The ID of this content."""
  id: ID!

  """Whether or not this content is supporter only."""
  isSupporterOnly: Boolean!

  """The resource belonging to this content."""
  resource: Resource!

  """
  The resource for the supporter-only content.
  
  If "viewerCanViewSupporterOnlyContent" is false, then this field will contain
  the original resource, with the URLs omitted. This allows you to use the
  details, such as the type (since the resource in the "resource" box will
  always be an image) or see the duration of the video.
  
  This field will be nil if "viewerCanViewSupporterOnlyContent" is true
  """
  supporterOnlyResource: Resource

  """Whether or not the viewer is able to see this content."""
  viewerCanViewSupporterOnlyContent: Boolean!
}

type PostEdge {
  cursor: String!
  node: Post!
}

type PostLike implements Node {
  """The account this like belongs to"""
  account: Account!

  """An ID uniquely identifying this like."""
  id: ID!

  """The time and date at which the post was liked."""
  likedAt: Time!

  """The post this like belongs to."""
  post: Post!
}

type PostModerator {
  """The ID to identify this post moderator item."""
  id: ID!

  """The moderator.."""
  moderator: Account!

  """When this post queue item was initially placed in the queue."""
  placedAt: Time!

  """The post linked to this post moderator."""
  post: Post!

  """When this post queue item will be reassigned."""
  reassignmentAt: Time!
}

type PostModeratorConnection {
  edges: [PostModeratorEdge!]!
  pageInfo: PageInfo!
}

type PostModeratorEdge {
  cursor: String!
  node: PostModerator!
}

"""Post report"""
type PostReport implements Node {
  """The account that initiated this report"""
  account: Account!

  """ID of the report"""
  id: ID!

  """The post linked to this report."""
  post: Post!

  """The rule that was cited for this report."""
  rule: Rule!
}

"""Connection of the post report"""
type PostReportConnection {
  edges: [PostReportEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the post report"""
type PostReportEdge {
  cursor: String!
  node: PostReport!
}

"""Properties by which posts connections can be sorted."""
enum PostsSort {
  """Posts by newest first"""
  NEW

  """Posts by top likes"""
  TOP
}

enum PostState {
  ARCHIVED
  DISCARDED
  DRAFT
  PUBLISHED
  REJECTED
  REMOVED
  REVIEW
}

"""Type describing a price."""
type Price {
  """
  The amount.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  amount: Int!

  """The currency the amount is represented in."""
  currency: Currency!
}

"""Update alias slug to default."""
input PromoteClubSlugAliasToDefaultInput {
  """The club to update"""
  id: ID!

  """The chosen slug for the club."""
  slug: String!
}

"""Payload for a new alt slug"""
type PromoteClubSlugAliasToDefaultPayload {
  """The club after update"""
  club: Club
}

type Query {
  """Look up a single account"""
  account(
    """Look up a post by a username"""
    username: String!
  ): Account

  """Grab a single account subscription by the reference."""
  accountClubSupporterSubscription(reference: String!): AccountClubSupporterSubscription

  """Grab a single account transaction by the reference."""
  accountTransaction(reference: String!): AccountTransaction

  """Get a single audience."""
  audience(
    """Search by slug of the audience."""
    slug: String!
  ): Audience

  """Search all audiences."""
  audiences(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by audience slugs."""
    slugs: [String!]

    """Sorting options for audiences."""
    sortBy: AudiencesSort! = POPULAR

    """Search by title of the audience."""
    title: String
  ): AudienceConnection!

  """Get a cancellation reason by reference."""
  cancellationReason(reference: String!): CancellationReason

  """Get all reasons for the site."""
  cancellationReasons(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Whether or not to show deprecated reasons."""
    deprecated: Boolean! = false

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): CancellationReasonConnection!

  """Search all categories."""
  categories(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by category slugs."""
    slugs: [String!]

    """Sorting options for categories."""
    sortBy: CategoriesSort! = POPULAR

    """Filter by the title of the category."""
    title: String
  ): CategoryConnection!

  """Get a single category."""
  category(
    """Search by slug of the category."""
    slug: String!
  ): Category

  """
  Grab more details about a ccbill subscription, passing in the ID.
  
  Staff+ only.
  """
  ccbillSubscriptionDetails(ccbillSubscriptionId: String!): CCBillSubscriptionDetails

  """
  After a successful transaction (through CCBill FlexForms or becomeClubSupporterWithAccountSavedPaymentMethod),
  use the returned token in this query to grab the current state of the transaction.
  
  It will tell you if the transaction was approved or denied, as well as having
  the ability to poll until a subscription is finalized.
  """
  ccbillTransactionDetails(token: String!): CCBillTransactionDetails

  """Get a single character."""
  character(
    """
    A club slug is required since character slugs are unique-per-series. Must enter either a series slug, or a club slug.
    """
    clubSlug: String

    """
    A series slug is required since character slugs are unique-per-series. Must enter either a series slug, or a club slug.
    """
    seriesSlug: String

    """Search by slug of the character."""
    slug: String!
  ): Character

  """Get or search all characters"""
  characters(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """
    Whether or not to show characters that were created by a club.
    
    By default, shows all characters.
    
    Otherwise, if true, shows all characters that were created by a club. If false, shows only series characters.
    """
    clubCharacters: Boolean

    """
    When searching for a character by slug, you need to include the club' slug since slugs are unique-per-series.
    
    Only one slug is allowed for now since you don't want inaccurate results.
    """
    clubSlug: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the character."""
    name: String

    """
    When searching for a character by slug, you need to include the series' slug since slugs are unique-per-series.
    
    Only one slug is allowed for now since you don't want inaccurate results.
    """
    seriesSlug: String

    """Search by character slugs."""
    slugs: [String!]

    """Sorting options for characters."""
    sortBy: CharactersSort! = POPULAR
  ): CharacterConnection!

  """Get a single club."""
  club(
    """Search by slug of the club."""
    slug: String!
  ): Club

  """Search multiple clubs."""
  clubs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the club."""
    name: String

    """Search by club slugs."""
    slugs: [String!]

    """Sorting options for clubs."""
    sortBy: ClubsSort! = POPULAR

    """
    Filter by all the clubs that are suspended.
    
    By default, will show all clubs that are suspended and terminated.
    
    False to show all clubs that are not suspended and True to show only clubs that are suspended.
    """
    suspended: Boolean

    """
    Filter by all the clubs that are terminated.
    
    By default, will show all terminated clubs.
    
    False to show all clubs that are not terminated and True to show only clubs that are terminated.
    """
    terminated: Boolean
  ): ClubConnection!

  """Grab all available countries."""
  countries: [Country!]!

  """Look up a single deposit request by reference."""
  depositRequest(reference: String!): DepositRequest

  """All deposit requests on the platform."""
  depositRequests(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): DepositRequestConnection!

  """Club discovery endpoint."""
  discoverClubs(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ClubConnection!

  """
  List of all available languages
  
  Should be used as a reference for back-end queries when requesting a specific
  language or adding a new language to a backend list
  """
  languages: [Language!]!

  """Fetch a node by the ID"""
  node(id: ID!): Node

  """Look up a single payment by reference."""
  payment(reference: String!): ClubPayment

  """All payments made on the platform."""
  payments(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of the payment."""
    status: [ClubPaymentStatus!]
  ): ClubPaymentConnection!

  """Look up a single payout by reference."""
  payout(reference: String!): ClubPayout

  """All payouts made on the platform."""
  payouts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the status of the payout."""
    status: [ClubPayoutStatus!]
  ): ClubPayoutConnection!

  """Look up a single post"""
  post(
    """Look up a post by a reference #"""
    reference: String!
  ): Post

  """All post reports."""
  postReports(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """From which date the post reports should be shown."""
    from: Time!

    """Returns the last _n_ elements from the list."""
    last: Int

    """
    The end date of the post reports. Optional - if not specified, will search through all-time.
    """
    to: Time
  ): PostReportConnection!

  """Search multiple posts"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    seriesSlugs: [String!]

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """Posts feed. The default."""
  postsFeed(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): PostConnection!

  """Get a single rule by reference."""
  rule(reference: String!): Rule

  """Get all rules for the site."""
  rules(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Whether or not to show deprecated rules."""
    deprecated: Boolean! = false

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): RuleConnection!

  """Perform a search across multiple types."""
  search(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """What you want to search."""
    query: String!
  ): SearchConnection!

  """Get a single serial."""
  serial(
    """Search by slug of the serial."""
    slug: String!
  ): Series

  """Get or search all series"""
  series(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by series slugs."""
    slugs: [String!]

    """Sorting options for series."""
    sortBy: SeriesSort! = POPULAR

    """Filter by the title of the series."""
    title: String
  ): SeriesConnection!

  """Get a single topic."""
  topic(
    """Search by slug of the topic."""
    slug: String!
  ): Topic

  """
  Search all topics.
  
  Topics are sorted by the "weight" field. Higher weights are displayed at the top, in descending order.
  """
  topics(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): TopicConnection!

  """
  Get the status of the authentication token - whether or not it is redeemed, account status, etc..
  
  Note: you can only view the authentication token if you're the originating
  device or you have entered a valid secret (not from same device)
  """
  viewAuthenticationToken(secret: String, token: String!): AuthenticationToken

  """Get the currently-authenticated account"""
  viewer: Account
}

"""Refund an account transaction."""
input RefundAccountTransactionInput {
  """The id of the subscription."""
  accountTransactionId: ID!

  """
  The amount to refund.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  amount: Int!
}

"""Payload for refunding an account transaction."""
type RefundAccountTransactionPayload {
  """The updated account transaction."""
  accountTransaction: AccountTransaction
}

"""A generated refund amount."""
type RefundAmount {
  """The currency."""
  currency: Currency!

  """
  The maximum amount you can issue a refund for.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  maximumAmount: Int!

  """
  A prorated refund amount, based on the first date and last date of billing / billing duration.
  
  A positive integer representing the currency in the smallest currency unit.
  """
  proratedAmount: Int!
}

"""Moderate the pending post input"""
input RejectPostInput {
  """Any extra notes for the moderator"""
  notes: String

  """Pending post to take action against"""
  postId: ID!

  """Required to enter a rule ID."""
  ruleId: ID!
}

"""Reject the pending post payload"""
type RejectPostPayload {
  """The resulting post"""
  post: Post
}

"""Update category."""
input RemoveCategoryAlternativeTitleInput {
  """The category to update"""
  id: ID!

  """The title to remove."""
  title: String!
}

"""Payload for updating category"""
type RemoveCategoryAlternativeTitlePayload {
  """The category after update"""
  category: Category
}

"""Remove a club infraction."""
input RemoveClubInfractionHistoryInput {
  """The history item to remove."""
  clubInfractionHistoryId: ID!
}

"""Remove club infraction history."""
type RemoveClubInfractionHistoryPayload {
  """The removed infraction history Id."""
  clubInfractionHistoryId: ID!
}

"""Remove alias slug."""
input RemoveClubSlugAliasInput {
  """The club to update"""
  id: ID!

  """The chosen slug for the club."""
  slug: String!
}

"""Payload for a new alt slug"""
type RemoveClubSlugAliasPayload {
  """The club after update"""
  club: Club
}

"""Remove moderator from posts queue."""
input RemoveModeratorFromPostQueueInput {
  """The moderator account to take the action on"""
  accountId: ID!
}

"""Remove moderator from posts queue."""
type RemoveModeratorFromPostQueuePayload {
  """The account that was updated"""
  account: Account
}

"""Remove post content."""
input RemovePostContentInput {
  """Content IDs for the content"""
  contentIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type RemovePostContentPayload {
  """The post after the update"""
  post: Post
}

"""Moderate the pending post input"""
input RemovePostInput {
  """Any extra notes for the staff member"""
  notes: String

  """Pending post to take action against"""
  postId: ID!

  """Required to enter a rule ID."""
  ruleId: ID!
}

"""Remove the pending post payload"""
type RemovePostPayload {
  """The resulting post"""
  post: Post
}

"""Report the post input"""
input ReportPostInput {
  """The post to report"""
  postId: ID!

  """The rule to report this post for."""
  ruleId: ID!
}

"""Report the post payload"""
type ReportPostPayload {
  """The post report that was generated"""
  postReport: PostReport
}

"""
A resource represents an image or a video format that contains an ID to uniquely identify it,
and urls to access the resources. We have many urls in order to provide a fallback for older browsers

We also identify the type of resource (image or video) to make it easy to distinguish them
"""
type Resource {
  """
  Whether or not this resource failed to process.
  
  A failure can happen if:
  - The supplied image is an unsupported format. This can happen if for example,
  someone submits a JPEG (unsupported) that was renamed to a PNG (supported)
  - The supplied image is corrupted.
  - The supplied video is invalid or corrupted.
  """
  failed: Boolean!

  """The height."""
  height: Int!

  """An ID uniquely identifying this resource."""
  id: ID!

  """
  A hex-code color of the resource that can be used in-place while the resource is loading.
  """
  preview: String!

  """
  Whether or not the resource is processed. Can be used for additional permission checks.
  """
  processed: Boolean!

  """
  This field identifies the progress for the resource.
  
  If the resource is not yet processed, this will not be nil.
  
  If we have some sort of state information available about the progress, this will not be nil.
  """
  progress: ResourceProgress

  """The type of resource - either an image or a video."""
  type: ResourceType!

  """URLs to access the resource."""
  urls: [ResourceUrl!]!

  """Duration, if video."""
  videoDuration: Int!

  """Whether or not the video has audio."""
  videoNoAudio: Boolean!

  """Video thumbnail, if video."""
  videoThumbnail: ResourceUrl

  """The width."""
  width: Int!
}

type ResourceProgress {
  id: ID!

  """The progress percent, in float. Will never be larger than 100."""
  progress: Float!

  """The state at which this resource is at."""
  state: ResourceProgressState!
}

enum ResourceProgressState {
  """Resource is finalizing processing."""
  FINALIZING

  """Resource has started processing."""
  STARTED

  """Resource is waiting to be processed."""
  WAITING
}

"""Identifies the type of resource"""
enum ResourceType {
  IMAGE
  VIDEO
}

"""A type representing a url to the resource and the mimetype"""
type ResourceUrl {
  mimeType: String!
  url: URI!
}

"""Retry a specific payout."""
input RetryClubPayoutInput {
  """The payout to retry."""
  payoutId: ID!
}

"""Payload for retrying the payout."""
type RetryClubPayoutPayload {
  """The updated club payout."""
  clubPayout: ClubPayout
}

"""Payload for revoking the current viewer"""
type RevokeAccountAccessPayload {
  """The account that was revoked"""
  revokedAccountId: ID!
}

"""Input to revoke artist role"""
input RevokeAccountArtistRole {
  """The account ID that the role needs to be revoked from"""
  accountId: ID!
}

"""Revoked account"""
type RevokeAccountArtistRolePayload {
  """The account that the role was revoked from"""
  account: Account
}

"""Input to revoke moderator role"""
input RevokeAccountModeratorRole {
  """The account ID that the role needs to be revoked from"""
  accountId: ID!
}

"""Revoked account"""
type RevokeAccountModeratorRolePayload {
  """The account that the role was revoked from"""
  account: Account
}

"""Input for updating an account's username"""
input RevokeAccountSessionInput {
  """Session ID that should be revoked"""
  accountSessionId: ID!
}

"""Payload of the revoked account session"""
type RevokeAccountSessionPayload {
  """The ID of the session that was revoked"""
  accountSessionId: ID!
}

"""Input to revoke staff role"""
input RevokeAccountStaffRole {
  """The account ID that the role needs to be revoked from"""
  accountId: ID!
}

"""Revoked account"""
type RevokeAccountStaffRolePayload {
  """The account that the role was revoked from"""
  account: Account
}

"""Input for revoking an authentication token"""
input RevokeAuthenticationTokenInput {
  """
  The secret associated with this token. Required if revoking the token not on the same device that created it.
  """
  secret: String

  """The token to revoke"""
  token: String!
}

"""Payload for revoking the authentication token"""
type RevokeAuthenticationTokenPayload {
  """The authentication token that was removed"""
  revokedAuthenticationTokenId: ID!
}

"""Rule."""
type Rule implements Node {
  """If this rule is deprecated."""
  deprecated: Boolean!

  """
  The description for this rule.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  description(locale: BCP47): String!

  """All translations for this description."""
  descriptionTranslations: [Translation!]!

  """ID of the rule."""
  id: ID!

  """
  If breaking this rule would cause an infraction - used for when posts are rejected or removed and this rule is applied.
  """
  infraction: Boolean!

  """Reference of the rule. Should be used for single lookups."""
  reference: String!

  """
  The title for this rule.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  title(locale: BCP47): String!

  """All translations for this title."""
  titleTranslations: [Translation!]!
}

"""Connection of the rule"""
type RuleConnection {
  edges: [RuleEdge!]!
  pageInfo: PageInfo!
}

"""Edge of the rule"""
type RuleEdge {
  cursor: String!
  node: Rule!
}

union Search = Category | Character | Club | Series

type SearchConnection {
  edges: [SearchEdge!]!
  pageInfo: PageInfo!
}

type SearchEdge {
  cursor: String!
  node: Search!
}

type Series implements Node {
  """A URL pointing to the object's banner."""
  banner: Resource

  """Get or search all characters for this series."""
  characters(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter by the name of the character."""
    name: String

    """Search by character slugs."""
    slugs: [String!]

    """Sorting options for characters."""
    sortBy: CharactersSort! = POPULAR
  ): CharacterConnection!

  """An ID pointing to this series."""
  id: ID!

  """Posts belonging to this series"""
  posts(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """Search by audience slugs."""
    audienceSlugs: [String!]

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Search by category slugs."""
    categorySlugs: [String!]

    """Search by character slugs."""
    characterSlugs: [String!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Sorting options for posts."""
    sortBy: PostsSort! = TOP

    """Search by a post state."""
    state: PostState = PUBLISHED

    """Search by a post supporter only status."""
    supporterOnlyStatus: [SupporterOnlyStatus!]
  ): PostConnection!

  """
  An ID that can be used to uniquely-identify this series. Never changes.
  """
  reference: String!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """A URL pointing to the object's thumbnail."""
  thumbnail: Resource

  """
  A title for this series.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  title(locale: BCP47): String!

  """All translations for this title."""
  titleTranslations: [Translation!]!

  """Total amount of likes."""
  totalLikes: Int!

  """Total amount of posts."""
  totalPosts: Int!
}

type SeriesConnection {
  edges: [SeriesEdge!]!
  pageInfo: PageInfo!
}

type SeriesEdge {
  cursor: String!
  node: Series!
}

"""Properties by which series connections can be sorted."""
enum SeriesSort {
  """Series by newest first"""
  NEW

  """Series by most posts"""
  POPULAR

  """Series by top likes"""
  TOP
}

"""Update account's payout method."""
input SetPaxumAccountPayoutMethodInput {
  """The paxum email to use for payouts."""
  email: String!
}

"""Payload for updating the payout method."""
type SetPaxumAccountPayoutMethodPayload {
  """The updated account payout method."""
  accountPayoutMethod: AccountPayoutMethod
}

"""Publish post."""
input SubmitPostInput {
  """The post to publish"""
  id: ID!
}

"""Payload for submitting a post"""
type SubmitPostPayload {
  """The post after being submitted"""
  post: Post
}

enum SupporterOnlyStatus {
  """All of the content is supporter-only."""
  FULL

  """None of the content requires supporting to view."""
  NONE

  """
  Some of the content requires supporting to view, at least 1 content piece is free.
  """
  PARTIAL
}

"""Suspend the club."""
input SuspendClubInput {
  """The club to suspend."""
  clubId: ID!

  """When the suspension should end."""
  endTime: Time!
}

"""Suspend club payload."""
type SuspendClubPayload {
  """The new club after it's suspended."""
  club: Club
}

"""Terminate the club."""
input TerminateClubInput {
  """The club to terminate."""
  clubId: ID!
}

"""Terminate club payload."""
type TerminateClubPayload {
  """The new club after it's terminated."""
  club: Club
}

scalar Time

type Topic implements Node {
  """A URL pointing to the object's banner."""
  banner: Resource

  """All categories linked to this topic."""
  categories(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Search by category slugs."""
    slugs: [String!]

    """Sorting options for categories."""
    sortBy: CategoriesSort! = POPULAR

    """Filter by the title of the category."""
    title: String
  ): CategoryConnection!

  """
  A description for this topic.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  description(locale: BCP47): String!

  """All translations for this topic."""
  descriptionTranslations: [Translation!]!

  """An ID pointing to this topic."""
  id: ID!

  """
  An ID that can be used to uniquely-identify this category. Never changes.
  """
  reference: String!

  """A url-friendly ID. Should be used when searching"""
  slug: String!

  """
  A title for this topic.
  
  Optionally pass a locale to display it in a specific language. English by default.
  """
  title(locale: BCP47): String!

  """All translations for this title."""
  titleTranslations: [Translation!]!

  """The weight of this topic."""
  weight: Int!
}

type TopicConnection {
  edges: [TopicEdge!]!
  pageInfo: PageInfo!
}

type TopicEdge {
  cursor: String!
  node: Topic!
}

type Translation {
  """The language linked to this translation."""
  language: Language!

  """The translation text."""
  text: String!
}

"""Un-Archive post."""
input UnArchivePostInput {
  """The post to un-archive"""
  id: ID!
}

"""Payload for un-archiving a post"""
type UnArchivePostPayload {
  """The un-archived post."""
  post: Post
}

"""Undo like on a post."""
input UndoLikePostInput {
  """The post ID that you want to unlike"""
  id: ID!
}

"""Payload for undoing a post like"""
type UndoLikePostPayload {
  """The post like that was deleted."""
  postLikeId: ID
}

"""Input for unlocking an account"""
input UnlockAccountInput {
  """The account to unlock."""
  accountID: ID!
}

"""Payload for the unlocked account"""
type UnlockAccountPayload {
  """Account that was unlocked"""
  account: Account
}

"""Un-Suspend the club."""
input UnSuspendClubInput {
  """The club to un-suspend."""
  clubId: ID!
}

"""Un suspend club payload."""
type UnSuspendClubPayload {
  """The new club after it's not suspended anymore."""
  club: Club
}

"""Un-Terminate the club."""
input UnTerminateClubInput {
  """The club to un-terminate."""
  clubId: ID!
}

"""Un terminate club payload."""
type UnTerminateClubPayload {
  """The new club after it's not terminated anymore."""
  club: Club
}

"""Update account details."""
input UpdateAccountDetailsInput {
  """The country ID to use."""
  countryId: ID!

  """The first name to set."""
  firstName: String!

  """The last name to set."""
  lastName: String!
}

"""Payload for the new updated account details."""
type UpdateAccountDetailsPayload {
  """The updated account details."""
  accountDetails: AccountDetails
}

"""Input for updating the account status to primary"""
input UpdateAccountEmailStatusToPrimaryInput {
  """The email that should be updated"""
  accountEmailId: ID!
}

"""Payload of the updated account email"""
type UpdateAccountEmailStatusToPrimaryPayload {
  """The account email that was updated to primary"""
  primaryAccountEmail: AccountEmail

  """The account email that was updated to 'confirmed' status"""
  updatedAccountEmail: AccountEmail
}

"""Input for updating an account's username"""
input UpdateAccountUsernameInput {
  """The username that the account should be updated to"""
  username: String!
}

"""Payload of the updated username"""
type UpdateAccountUsernamePayload {
  """The account that was modified"""
  account: Account

  """Validation for taking an account username"""
  validation: UpdateAccountUsernameValidation
}

"""Validation message for updating account username"""
enum UpdateAccountUsernameValidation {
  USERNAME_TAKEN
}

"""Update audience."""
input UpdateAudienceBannerInput {
  """The banner"""
  banner: String!

  """The audience to update"""
  id: ID!
}

"""Payload for updating audience"""
type UpdateAudienceBannerPayload {
  """The audience after update"""
  audience: Audience
}

"""Update audience."""
input UpdateAudienceIsStandardInput {
  """The audience to update"""
  id: ID!

  """Standard"""
  standard: Boolean!
}

"""Payload for updating audience"""
type UpdateAudienceIsStandardPayload {
  """The audience after update"""
  audience: Audience
}

"""Update audience."""
input UpdateAudienceThumbnailInput {
  """The audience to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating audience"""
type UpdateAudienceThumbnailPayload {
  """The audience after update"""
  audience: Audience
}

"""Update audience."""
input UpdateAudienceTitleInput {
  """The audience to update"""
  id: ID!

  """The localization for this title"""
  locale: BCP47!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating audience"""
type UpdateAudienceTitlePayload {
  """The audience after update"""
  audience: Audience
}

"""Update reason."""
input UpdateCancellationReasonDeprecatedInput {
  """The cancellation reason to update."""
  cancellationReasonId: ID!

  """The deprecated status."""
  deprecated: Boolean!
}

"""Updated reason."""
type UpdateCancellationReasonDeprecatedPayload {
  """The updated reason."""
  cancellationReason: CancellationReason
}

"""Update cancellation reason."""
input UpdateCancellationReasonTitleInput {
  """The reason to update."""
  cancellationReasonId: ID!

  """The localization for this title."""
  locale: BCP47!

  """The title to update"""
  title: String!
}

"""Updated reason."""
type UpdateCancellationReasonTitlePayload {
  """The updated reason."""
  cancellationReason: CancellationReason
}

"""Update category."""
input UpdateCategoryThumbnailInput {
  """The category to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating category"""
type UpdateCategoryThumbnailPayload {
  """The category after update"""
  category: Category
}

"""Update category."""
input UpdateCategoryTitleInput {
  """The category to update"""
  id: ID!

  """The localization for this title"""
  locale: BCP47!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating category"""
type UpdateCategoryTitlePayload {
  """The category after update"""
  category: Category
}

"""Update category topic."""
input UpdateCategoryTopicInput {
  """The category to update"""
  id: ID!

  """The topic to assign to this category."""
  topicId: ID!
}

"""Payload for updating category"""
type UpdateCategoryTopicPayload {
  """The category after update"""
  category: Category
}

"""Update character."""
input UpdateCharacterNameInput {
  """The character to update"""
  id: ID!

  """
  The localization for this name.
  
  Validation: Must be one of the languages from the languages query.
  """
  locale: BCP47!

  """
  The name to update.
  
  Validation: Max 25 characters.
  """
  name: String!
}

"""Payload for updating character"""
type UpdateCharacterNamePayload {
  """The character after update"""
  character: Character
}

"""Update character."""
input UpdateCharacterThumbnailInput {
  """The character to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating character"""
type UpdateCharacterThumbnailPayload {
  """The character after update"""
  character: Character
}

"""Update club characters limit."""
input UpdateClubCharactersLimitInput {
  """
  The amount of characters the club will be able to create.
  
  Validation: Limit to 200.
  """
  charactersLimit: Int!

  """The club to update club characters limit for."""
  clubId: ID!
}

"""Update club characters limit payload."""
type UpdateClubCharactersLimitPayload {
  """The club after updating the characters limit."""
  club: Club
}

"""Update club name."""
input UpdateClubNameInput {
  """The club to update"""
  id: ID!

  """
  The chosen name for the club.
  
  Validation: Max 25 characters.
  """
  name: String!
}

"""Payload for updating the name"""
type UpdateClubNamePayload {
  """The club after update"""
  club: Club
}

"""Update the payout date for a specific payout ID."""
input UpdateClubPayoutDepositDateInput {
  """The new payout date."""
  newDate: Time!

  """The payout to update."""
  payoutId: ID!
}

"""Payload for updating the payout deposit date."""
type UpdateClubPayoutDepositDatePayload {
  """The updated club payout."""
  clubPayout: ClubPayout
}

"""Update the club's platform fee."""
input UpdateClubPlatformFeeInput {
  """The club to update."""
  clubId: ID!

  """The percent fee to take from every payment."""
  percent: Int!
}

"""Payload for the new updated account details."""
type UpdateClubPlatformFeePayload {
  """The updated club platform fee."""
  clubPlatformFee: ClubPlatformFee
}

"""Update club thumbnail."""
input UpdateClubThumbnailInput {
  """The club to update"""
  id: ID!

  """The thumbnail for the club."""
  thumbnail: String!
}

"""Payload for updating the thumbnail"""
type UpdateClubThumbnailPayload {
  """The club after update"""
  club: Club
}

"""Update curation profile audience."""
input UpdateCurationProfileAudienceInput {
  """The audiences that were selected"""
  audienceIds: [ID!]!

  """Whether or not this section was skipped"""
  skipped: Boolean!
}

"""Payload for updating profile audience"""
type UpdateCurationProfileAudiencePayload {
  """The updated profile."""
  curationProfile: CurationProfile
}

"""Update curation profile category."""
input UpdateCurationProfileCategoryInput {
  """The categories that were selected"""
  categoryIds: [ID!]!

  """Whether or not this section was skipped"""
  skipped: Boolean!
}

"""Payload for updating profile category"""
type UpdateCurationProfileCategoryPayload {
  """The updated profile."""
  curationProfile: CurationProfile
}

"""Update curation profile date of birth."""
input UpdateCurationProfileDateOfBirthInput {
  """The date of birth that was selected"""
  dateOfBirth: Time

  """Whether or not this section was skipped"""
  skipped: Boolean!
}

"""Payload for updating profile date of birth"""
type UpdateCurationProfileDateOfBirthPayload {
  """The updated profile."""
  curationProfile: CurationProfile
}

"""Update post audience."""
input UpdatePostAudienceInput {
  """The audience that this post belongs to"""
  audienceId: ID!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostAudiencePayload {
  """The post after the update"""
  post: Post
}

"""Update post audience."""
input UpdatePostCategoriesInput {
  """Category IDs for this post"""
  categoryIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostCategoriesPayload {
  """The post after the update"""
  post: Post
}

"""Update post characters."""
input UpdatePostCharactersInput {
  """Ids for all the characters"""
  characterIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostCharactersPayload {
  """The post after the update"""
  post: Post
}

"""Payload for updating a post"""
type UpdatePostClubPayload {
  """The post after the update"""
  post: Post
}

"""Update post content is supporter only."""
input UpdatePostContentIsSupporterOnlyInput {
  """Content IDs to update"""
  contentIds: [ID!]!

  """The post to update"""
  id: ID!

  """The change to make"""
  isSupporterOnly: Boolean!
}

"""Payload for updating a post"""
type UpdatePostContentIsSupporterOnlyPayload {
  """The post after the update"""
  post: Post
}

"""Update post content order."""
input UpdatePostContentOrderInput {
  """Content IDs for the content"""
  contentIds: [ID!]!

  """The post to update"""
  id: ID!
}

"""Payload for updating a post"""
type UpdatePostContentOrderPayload {
  """The post after the update"""
  post: Post
}

"""Update post."""
input UpdatePostDescriptionInput {
  """
  The description to update.
  
  Validation: Max 280 characters. No links allowed.
  """
  description: String!

  """The post to update"""
  id: ID!

  """
  The localization for this description.
  
  Locale must be one from the languages query, or else the locale won't be accepted.
  """
  locale: BCP47!
}

"""Payload for updating a post description"""
type UpdatePostDescriptionPayload {
  """The post after the update"""
  post: Post
}

"""Update post report reason."""
input UpdateRuleDeprecatedInput {
  """The deprecated status."""
  deprecated: Boolean!

  """The rule to update."""
  ruleId: ID!
}

"""Updated rule."""
type UpdateRuleDeprecatedPayload {
  """The updated rule."""
  rule: Rule
}

"""Update rule."""
input UpdateRuleDescriptionInput {
  """
  The description to update.
  
  Validation: Max 25 characters. Markdown allowed.
  """
  description: String!

  """The localization for this description."""
  locale: BCP47!

  """The rule to update."""
  ruleId: ID!
}

"""Updated rule."""
type UpdateRuleDescriptionPayload {
  """The updated rule."""
  rule: Rule
}

"""Update post report reason."""
input UpdateRuleInfractionInput {
  """The infraction status."""
  infraction: Boolean!

  """The rule to update."""
  ruleId: ID!
}

"""Updated rule."""
type UpdateRuleInfractionPayload {
  """The updated rule."""
  rule: Rule
}

"""Update rule."""
input UpdateRuleTitleInput {
  """The localization for this title."""
  locale: BCP47!

  """The rule to update."""
  ruleId: ID!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Updated rule."""
type UpdateRuleTitlePayload {
  """The updated rule."""
  rule: Rule
}

"""Update series."""
input UpdateSeriesThumbnailInput {
  """The series to update"""
  id: ID!

  """The thumbnail"""
  thumbnail: String!
}

"""Payload for updating series"""
type UpdateSeriesThumbnailPayload {
  """The category after update"""
  series: Series
}

"""Update series."""
input UpdateSeriesTitleInput {
  """The series to update"""
  id: ID!

  """
  The localization for this title.
  
  Locale must be one from the languages query, or else the locale won't be accepted.
  """
  locale: BCP47!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating series"""
type UpdateSeriesTitlePayload {
  """The series after update"""
  series: Series
}

"""Update topic."""
input UpdateTopicBannerInput {
  """The banner"""
  banner: String!

  """The category to update"""
  id: ID!
}

"""Payload for updating topic"""
type UpdateTopicBannerPayload {
  """The topic after update"""
  topic: Topic
}

"""Update topic."""
input UpdateTopicDescriptionInput {
  """
  The description to update.
  
  Validation: Markdown allowed.
  """
  description: String!

  """The topic to update"""
  id: ID!

  """The localization for this description"""
  locale: BCP47!
}

"""Payload for updating topic"""
type UpdateTopicDescriptionPayload {
  """The topic after update"""
  topic: Topic
}

"""Update topic."""
input UpdateTopicTitleInput {
  """The topic to update"""
  id: ID!

  """The localization for this title"""
  locale: BCP47!

  """
  The title to update.
  
  Validation: Max 25 characters.
  """
  title: String!
}

"""Payload for updating topic"""
type UpdateTopicTitlePayload {
  """The topic after update"""
  topic: Topic
}

"""Update topic."""
input UpdateTopicWeightInput {
  """The topic to update"""
  id: ID!

  """The weight to update to."""
  weight: Int!
}

"""Payload for updating topic"""
type UpdateTopicWeightPayload {
  """The topic after update"""
  topic: Topic
}

"""An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string."""
scalar URI

"""Input for verifying authentication token"""
input VerifyAuthenticationTokenInput {
  """Secret (get it from the email)"""
  secret: String!

  """The original token"""
  token: String!
}

"""Payload for verifying the authentication token"""
type VerifyAuthenticationTokenPayload {
  """The authentication token"""
  authenticationToken: AuthenticationToken

  """Validation options"""
  validation: VerifyAuthenticationTokenValidation
}

"""Validation for granting account access"""
enum VerifyAuthenticationTokenValidation {
  TOKEN_INVALID
}
