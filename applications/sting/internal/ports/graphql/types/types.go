// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package types

import (
	"fmt"
	"io"
	graphql1 "overdoll/libraries/graphql"
	"overdoll/libraries/graphql/relay"
	"strconv"
	"time"
)

type ClubSuspensionLog interface {
	IsClubSuspensionLog()
}

// A union representing the status of various games.
type GameSessionStatus interface {
	IsGameSessionStatus()
}

type Search interface {
	IsSearch()
}

type Account struct {
	// Maximum amount of clubs that you can create.
	ClubsLimit int `json:"clubsLimit"`
	// Current count of the amount of clubs that the account has created.
	ClubsCount int `json:"clubsCount"`
	// Whether or not this club has non-terminated clubs.
	//
	// Cannot delete account if this is true.
	HasNonTerminatedClubs bool `json:"hasNonTerminatedClubs"`
	// Represents the clubs that the account has created.
	Clubs *ClubConnection `json:"clubs"`
	// Maximum amount of clubs that you can join as an account.
	ClubMembershipsLimit int `json:"clubMembershipsLimit"`
	// Current count of club memberships. Should be compared against the limit before joining a club.
	ClubMembershipsCount int `json:"clubMembershipsCount"`
	// Represents the club memberships that the account has.
	ClubMemberships *ClubMemberConnection `json:"clubMemberships"`
	// The curation profile linked to this account.
	CurationProfile *CurationProfile `json:"curationProfile"`
	// Posts feed for the clubs that the account currently is a member of.
	ClubMembersPostsFeed *PostConnection `json:"clubMembersPostsFeed"`
	// Contributions specific to this account
	Posts *PostConnection `json:"posts"`
	// All posts liked by this account, sorted by most recent.
	LikedPosts *PostConnection `json:"likedPosts"`
	ID         relay.ID        `json:"id"`
}

func (Account) IsEntity() {}

// Update category.
type AddCategoryAlternativeTitleInput struct {
	// The category to update
	ID relay.ID `json:"id"`
	// The title to add.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// The localization for this title
	Locale string `json:"locale"`
}

// Payload for updating category
type AddCategoryAlternativeTitlePayload struct {
	// The category after update
	Category *Category `json:"category"`
}

// Add alias slug.
type AddClubSlugAliasInput struct {
	// The club to update
	ID relay.ID `json:"id"`
	// The chosen slug for the club.
	//
	// Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
	Slug string `json:"slug"`
}

// Payload for a new alt slug
type AddClubSlugAliasPayload struct {
	// The club after update
	Club *Club `json:"club"`
	// Validation for adding a new club
	Validation *AddClubSlugAliasValidation `json:"validation"`
}

// Add post content.
type AddPostContentInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// Image IDs for the content
	Content []string `json:"content"`
}

// Payload for updating a post
type AddPostContentPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Archive post.
type ArchivePostInput struct {
	// The post to archive
	ID relay.ID `json:"id"`
}

// Payload for archiving a post
type ArchivePostPayload struct {
	// The archived post.
	Post *Post `json:"post"`
}

type Audience struct {
	// An ID pointing to this audience.
	ID relay.ID `json:"id"`
	// An ID that can be used to uniquely-identify this audience. Never changes.
	Reference string `json:"reference"`
	// A url-friendly ID. Should be used when searching.
	Slug string `json:"slug"`
	// A URL pointing to the object's thumbnail.
	Thumbnail *graphql1.Resource `json:"thumbnail"`
	// A URL pointing to the object's banner.
	Banner *graphql1.Resource `json:"banner"`
	// A title for this audience.
	//
	// Optionally pass a locale to display it in a specific language. English by default.
	Title string `json:"title"`
	// If this audience is standard or not.
	Standard bool `json:"standard"`
	// All translations for this title.
	TitleTranslations []*graphql1.Translation `json:"titleTranslations"`
	// Total amount of likes.
	TotalLikes int `json:"totalLikes"`
	// Total amount of posts.
	TotalPosts int `json:"totalPosts"`
	// Posts belonging to this audience
	Posts *PostConnection `json:"posts"`
}

func (Audience) IsNode()   {}
func (Audience) IsEntity() {}

type AudienceConnection struct {
	Edges    []*AudienceEdge `json:"edges"`
	PageInfo *relay.PageInfo `json:"pageInfo"`
}

type AudienceCurationProfile struct {
	// Whether or not the audience section was completed.
	Completed bool `json:"completed"`
	// Whether or not the audience section was skipped.
	Skipped bool `json:"skipped"`
	// Audiences selected for this section.
	Audiences []*Audience `json:"audiences"`
}

type AudienceEdge struct {
	Cursor string    `json:"cursor"`
	Node   *Audience `json:"node"`
}

type Category struct {
	// An ID pointing to this category.
	ID relay.ID `json:"id"`
	// An ID that can be used to uniquely-identify this category. Never changes.
	Reference string `json:"reference"`
	// A url-friendly ID. Should be used when searching
	Slug string `json:"slug"`
	// A URL pointing to the object's thumbnail.
	Thumbnail *graphql1.Resource `json:"thumbnail"`
	// A URL pointing to the object's banner.
	Banner *graphql1.Resource `json:"banner"`
	// A title for this category.
	//
	// Optionally pass a locale to display it in a specific language. English by default.
	Title string `json:"title"`
	// All translations for this title.
	TitleTranslations []*graphql1.Translation `json:"titleTranslations"`
	// Alternative titles for this category.
	AlternativeTitles []*graphql1.Translation `json:"alternativeTitles"`
	// Total amount of likes.
	TotalLikes int `json:"totalLikes"`
	// Total amount of posts.
	TotalPosts int `json:"totalPosts"`
	// The topic linked this category. If no topic is linked, field is null.
	Topic *Topic `json:"topic"`
	// Posts belonging to this category
	Posts *PostConnection `json:"posts"`
}

func (Category) IsNode()   {}
func (Category) IsSearch() {}
func (Category) IsEntity() {}

type CategoryConnection struct {
	Edges    []*CategoryEdge `json:"edges"`
	PageInfo *relay.PageInfo `json:"pageInfo"`
}

type CategoryCurationProfile struct {
	// Whether or not the category section was completed.
	Completed bool `json:"completed"`
	// Whether or not the category section was skipped.
	Skipped bool `json:"skipped"`
	// Categories selected for this section.
	Categories []*Category `json:"categories"`
}

type CategoryEdge struct {
	Cursor string    `json:"cursor"`
	Node   *Category `json:"node"`
}

type Character struct {
	// An ID pointing to this character.
	ID relay.ID `json:"id"`
	// An ID that can be used to uniquely-identify this character. Never changes.
	Reference string `json:"reference"`
	// A url-friendly ID. Should be used when searching
	Slug string `json:"slug"`
	// A URL pointing to the object's thumbnail.
	Thumbnail *graphql1.Resource `json:"thumbnail"`
	// A URL pointing to the object's banner.
	Banner *graphql1.Resource `json:"banner"`
	// A name for this character.
	//
	// Optionally pass a locale to display it in a specific language. English by default.
	Name string `json:"name"`
	// All translations for this name.
	NameTranslations []*graphql1.Translation `json:"nameTranslations"`
	// Total amount of likes.
	TotalLikes int `json:"totalLikes"`
	// Total amount of posts.
	TotalPosts int `json:"totalPosts"`
	// The series linked to this character, if it's a series character.
	Series *Series `json:"series"`
	// The club linked to this character, if it was created by a club.
	Club *Club `json:"club"`
	// Posts belonging to this character
	Posts *PostConnection `json:"posts"`
}

func (Character) IsNode()   {}
func (Character) IsSearch() {}
func (Character) IsEntity() {}

type CharacterConnection struct {
	Edges    []*CharacterEdge `json:"edges"`
	PageInfo *relay.PageInfo  `json:"pageInfo"`
}

type CharacterEdge struct {
	Cursor string     `json:"cursor"`
	Node   *Character `json:"node"`
}

type Club struct {
	// An ID pointing to this club.
	ID relay.ID `json:"id"`
	// An internal reference, uniquely identifying the club.
	Reference string `json:"reference"`
	// A url-friendly ID. Should be used when searching
	Slug string `json:"slug"`
	// Maximum amount of slug aliases that can be created for this club.
	SlugAliasesLimit int `json:"slugAliasesLimit"`
	// The total number of posts for this club.
	TotalPosts int `json:"totalPosts"`
	// The total number of likes for this club.
	TotalLikes int `json:"totalLikes"`
	// An alias list of slugs. These are valid, as in, you can find the club using the slug. However, it should always be replaced by the default slug.
	SlugAliases []*ClubSlugAlias `json:"slugAliases"`
	// A resource of the club's thumbnail.
	Thumbnail *graphql1.Resource `json:"thumbnail"`
	// A resource of the club's banner.
	Banner *graphql1.Resource `json:"banner"`
	// A name for this club.
	Name string `json:"name"`
	// The account that owns this club.
	Owner *Account `json:"owner"`
	// Whether or not this club is terminated.
	Termination *ClubTermination `json:"termination"`
	// Whether or not this club is suspended.
	Suspension *ClubSuspension `json:"suspension"`
	// Club Suspension Logs.
	//
	// Can see who a club was suspended by, the reason and who unsuspended a particular club.
	SuspensionLogs *ClubSuspensionLogConnection `json:"suspensionLogs"`
	// Whether or not the viewer is the owner of the club.
	ViewerIsOwner bool `json:"viewerIsOwner"`
	// Whether creating supporter-only posts is enabled or disabled for this club.
	//
	// When this is true, a club owner cannot mark individual content in a post as "supporter-only".
	//
	// Additionally, if a club owner attempts to submit a post with supporter-only content already present, they will not be able to.
	CanCreateSupporterOnlyPosts bool `json:"canCreateSupporterOnlyPosts"`
	// Whether or not you can become a supporter of this club.
	CanSupport bool `json:"canSupport"`
	// When the owner of the club needs to post the next supporter post.
	//
	// Usually 30 days after the next post.
	//
	// Nil if no supporter-only posts have been created.
	NextSupporterPostTime *time.Time `json:"nextSupporterPostTime"`
	// Whether or not the viewer is a member of this club.
	ViewerMember *ClubMember `json:"viewerMember"`
	// The total amount of members in this club, who are supporters.
	MembersIsSupporterCount int `json:"membersIsSupporterCount"`
	// The total amount of members in this club.
	MembersCount int `json:"membersCount"`
	// Club members.
	Members *ClubMemberConnection `json:"members"`
	// Whether or not characters are enabled for this club.
	CharactersEnabled bool `json:"charactersEnabled"`
	// The amount of characters that this club can create.
	CharactersLimit int `json:"charactersLimit"`
	// The total amount of characters that this club has created.
	CharactersCount int `json:"charactersCount"`
	// Get or search all characters for this club.
	Characters *CharacterConnection `json:"characters"`
	// Posts belonging to this club
	Posts *PostConnection `json:"posts"`
}

func (Club) IsNode()   {}
func (Club) IsSearch() {}
func (Club) IsEntity() {}

type ClubConnection struct {
	Edges    []*ClubEdge     `json:"edges"`
	PageInfo *relay.PageInfo `json:"pageInfo"`
}

type ClubEdge struct {
	Cursor string `json:"cursor"`
	Node   *Club  `json:"node"`
}

type ClubIssuedSuspensionLog struct {
	// The ID linked to this suspension log.
	ID relay.ID `json:"id"`
	// The account that created this suspension.
	//
	// If nil, the suspension was created automatically
	Account *Account `json:"account"`
	// The reason this suspension was issued.
	Reason ClubSuspensionReason `json:"reason"`
	// How long the club was suspended until.
	SuspendedUntil time.Time `json:"suspendedUntil"`
}

func (ClubIssuedSuspensionLog) IsClubSuspensionLog() {}

type ClubMember struct {
	// An ID pointing to this club member.
	ID relay.ID `json:"id"`
	// When the membership was created (when the account originally joined).
	JoinedAt time.Time `json:"joinedAt"`
	// The club that this membership belongs to.
	Club *Club `json:"club"`
	// The account that belongs to this membership.
	Account *Account `json:"account"`
	// Whether or not this member is a supporter.
	IsSupporter bool `json:"isSupporter"`
	// If is a supporter, when they became a supporter.
	SupporterSince *time.Time `json:"supporterSince"`
}

func (ClubMember) IsNode()   {}
func (ClubMember) IsEntity() {}

type ClubMemberConnection struct {
	Edges    []*ClubMemberEdge `json:"edges"`
	PageInfo *relay.PageInfo   `json:"pageInfo"`
}

type ClubMemberEdge struct {
	Cursor string      `json:"cursor"`
	Node   *ClubMember `json:"node"`
}

type ClubRemovedSuspensionLog struct {
	// The ID linked to this suspension log.
	ID relay.ID `json:"id"`
	// The account that removed this suspension.
	Account *Account `json:"account"`
}

func (ClubRemovedSuspensionLog) IsClubSuspensionLog() {}

// The club slug alias
type ClubSlugAlias struct {
	// The slug alias
	Slug string `json:"slug"`
}

type ClubSuspension struct {
	// When the suspension expires. Can call UnSuspendClub when time = now.
	Expires time.Time `json:"expires"`
}

type ClubSuspensionLogConnection struct {
	Edges    []*ClubSuspensionLogEdge `json:"edges"`
	PageInfo *relay.PageInfo          `json:"pageInfo"`
}

type ClubSuspensionLogEdge struct {
	Cursor string            `json:"cursor"`
	Node   ClubSuspensionLog `json:"node"`
}

type ClubTermination struct {
	// The account that terminated the club.
	Account *Account `json:"account"`
}

// Create a new audience.
type CreateAudienceInput struct {
	// The chosen slug for the audience.
	//
	// Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
	Slug string `json:"slug"`
	// The chosen title for the audience.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// If the audience is standard or not.
	Standard bool `json:"standard"`
}

// Payload for a new audience
type CreateAudiencePayload struct {
	// The audience after creation
	Audience *Audience `json:"audience"`
	// Validation for creating a new audience
	Validation *CreateAudienceValidation `json:"validation"`
}

// Create a new category.
type CreateCategoryInput struct {
	// The chosen slug for the category.
	//
	// Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
	Slug string `json:"slug"`
	// The chosen title for the category.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// Optionally assign a topic to this category.
	TopicID *relay.ID `json:"topicId"`
}

// Payload for a new category
type CreateCategoryPayload struct {
	// The category after creation
	Category *Category `json:"category"`
	// Validation for creating a new category
	Validation *CreateCategoryValidation `json:"validation"`
}

// Create a new character.
type CreateCharacterInput struct {
	// The chosen series for the character.
	SeriesID *relay.ID `json:"seriesId"`
	// The chosen club for the character.
	ClubID *relay.ID `json:"clubId"`
	// The chosen slug for the character.
	//
	// Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
	Slug string `json:"slug"`
	// The chosen name for the character.
	//
	// Validation: Max 25 characters.
	Name string `json:"name"`
}

// Payload for a new character
type CreateCharacterPayload struct {
	// The character after creation
	Character *Character `json:"character"`
	// Validation for creating a new character
	Validation *CreateCharacterValidation `json:"validation"`
}

// Create club.
type CreateClubInput struct {
	// The chosen slug for the club.
	//
	// Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
	Slug string `json:"slug"`
	// The chosen name for the club.
	//
	// Validation: Max 25 characters.
	Name string `json:"name"`
}

// Payload for a new club
type CreateClubPayload struct {
	// The club after creation
	Club *Club `json:"club"`
	// Validation for creating a new club
	Validation *CreateClubValidation `json:"validation"`
}

// Create a new game session.
type CreateGameSessionInput struct {
	// The game type to create the session for.
	GameType GameType `json:"gameType"`
	// Optionally pass a seed. If a seed is not passed in, one will be automatically generated.
	//
	// Validation: only alphanumeric characters, no spaces, and max 25 characters.
	Seed *string `json:"seed"`
}

// Payload for a new game session
type CreateGameSessionPayload struct {
	// The game session after creation.
	GameSession *GameSession `json:"gameSession"`
}

// Create a new post. A club ID is required.
type CreatePostInput struct {
	// The club ID that this post will belong to
	ClubID relay.ID `json:"clubId"`
}

// Payload for a created pending post
type CreatePostPayload struct {
	// The pending post after the creation
	Post *Post `json:"post"`
}

// Create a new series.
type CreateSeriesInput struct {
	// The chosen slug for the series.
	//
	// Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
	Slug string `json:"slug"`
	// The chosen title for the series.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
}

// Payload for a new series
type CreateSeriesPayload struct {
	// The series after creation
	Series *Series `json:"series"`
	// Validation for creating a new series
	Validation *CreateSeriesValidation `json:"validation"`
}

// Create a new topic.
type CreateTopicInput struct {
	// The chosen slug for the topic.
	//
	// Validation: Max 25 characters. No spaces allowed. Alphanumeric characters.
	Slug string `json:"slug"`
	// The chosen title for the topic.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// The chosen description for the topic.
	//
	// Validation: Markdown allowed.
	Description string `json:"description"`
	// The assigned weight for this topic.
	Weight int `json:"weight"`
}

// Payload for a new topic
type CreateTopicPayload struct {
	// The topic after creation
	Topic *Topic `json:"topic"`
	// Validation for creating a new topic
	Validation *CreateTopicValidation `json:"validation"`
}

type CurationProfile struct {
	// An ID uniquely identifying this profile.
	ID relay.ID `json:"id"`
	// If the whole profile was completed or not.
	Completed bool `json:"completed"`
	// The date of birth profile.
	DateOfBirth *DateOfBirthCurationProfile `json:"dateOfBirth"`
	// The audience profile.
	Audience *AudienceCurationProfile `json:"audience"`
	// The category profile.
	Category *CategoryCurationProfile `json:"category"`
}

type DateOfBirthCurationProfile struct {
	// Whether or not the date of birth section was skipped.
	Skipped bool `json:"skipped"`
	// Whether or not the date of birth section was completed.
	Completed bool `json:"completed"`
	// The date of birth set.
	DateOfBirth *time.Time `json:"dateOfBirth"`
}

// Delete post.
type DeletePostInput struct {
	// The post to delete
	ID relay.ID `json:"id"`
}

// Payload for deleting a post
type DeletePostPayload struct {
	// The deleted post.
	PostID *relay.ID `json:"postId"`
}

// Disable club characters.
type DisableClubCharactersInput struct {
	// The club to disable characters for.
	ClubID relay.ID `json:"clubId"`
}

// Disable club characters payload.
type DisableClubCharactersPayload struct {
	// The new club after disabling club characters.
	Club *Club `json:"club"`
}

// Disable club supporter-only posts.
type DisableClubSupporterOnlyPostsInput struct {
	// The club to disable supporter-only posts for.
	ClubID relay.ID `json:"clubId"`
}

// Disable club supporter-only posts payload.
type DisableClubSupporterOnlyPostsPayload struct {
	// The new club after supporter-only posts are disabled.
	Club *Club `json:"club"`
}

// Enable club characters.
type EnableClubCharactersInput struct {
	// The club to enable club characters for.
	ClubID relay.ID `json:"clubId"`
	// The amount of characters the club will be able to create.
	//
	// Validation: Limit to 200.
	CharactersLimit int `json:"charactersLimit"`
}

// Enable club characters payload.
type EnableClubCharactersPayload struct {
	// The new club after enabling club characters.
	Club *Club `json:"club"`
}

// Enable club supporter-only posts.
type EnableClubSupporterOnlyPostsInput struct {
	// The club to enable supporter-only posts for.
	ClubID relay.ID `json:"clubId"`
}

// Enable club supporter-only posts payload.
type EnableClubSupporterOnlyPostsPayload struct {
	// The new club after supporter-only posts are enabled.
	Club *Club `json:"club"`
}

type GameSession struct {
	// An ID pointing to this game session.
	ID relay.ID `json:"id"`
	// An ID that can be used to uniquely-identify this game session.
	Reference string `json:"reference"`
	// Whether or not this game session is closed. A closed game session cannot be played anymore.
	IsClosed bool `json:"isClosed"`
	// Whether or not the current viewer is the player of the game. Only players can "play" the game.
	ViewerIsPlayer bool `json:"viewerIsPlayer"`
	// The type of game this session belongs to.
	GameType GameType `json:"gameType"`
	// The seed used for this session.
	Seed string `json:"seed"`
}

// Join a club input.
type JoinClubInput struct {
	// The chosen club ID.
	ClubID relay.ID `json:"clubId"`
}

// Payload for a new club member
type JoinClubPayload struct {
	// The membership after creation
	ClubMember *ClubMember `json:"clubMember"`
}

// Leave a club.
type LeaveClubInput struct {
	// The chosen club ID.
	ClubID relay.ID `json:"clubId"`
}

// Payload for leaving a club
type LeaveClubPayload struct {
	// The club membership that was removed
	ClubMemberID relay.ID `json:"clubMemberId"`
}

// Like a post.
type LikePostInput struct {
	// The post ID that you want to like
	ID relay.ID `json:"id"`
}

// Payload for the liked post
type LikePostPayload struct {
	// The new PostLike entry.
	PostLike *PostLike `json:"postLike"`
}

type Post struct {
	ID relay.ID `json:"id"`
	// The reference of this post. Should always be used to reference this post.
	Reference string `json:"reference"`
	// The state of the post.
	State PostState `json:"state"`
	// The supporter-only status.
	SupporterOnlyStatus SupporterOnlyStatus `json:"supporterOnlyStatus"`
	// The contributor who contributed this post
	Contributor *Account `json:"contributor"`
	// The club belonging to the post
	Club *Club `json:"club"`
	// Content belonging to this post
	Content []*PostContent `json:"content"`
	// A description for this post.
	//
	// Optionally pass a locale to display it in a specific language. English by default.
	Description string `json:"description"`
	// All translations for this description.
	DescriptionTranslations []*graphql1.Translation `json:"descriptionTranslations"`
	// The date and time of when this post was created
	CreatedAt time.Time `json:"createdAt"`
	// The date and time of when this post was posted
	PostedAt *time.Time `json:"postedAt"`
	// Suggested posts for this post.
	SuggestedPosts *PostConnection `json:"suggestedPosts"`
	// Represents the audience that this post belongs to
	Audience *Audience `json:"audience"`
	// Categories that belong to this post
	Categories []*Category `json:"categories"`
	// Characters that belong to this post
	Characters []*Character `json:"characters"`
	// The amount of likes on this post.
	Likes int `json:"likes"`
	// Whether or not the viewer liked this post.
	ViewerLiked *PostLike `json:"viewerLiked"`
}

func (Post) IsNode()   {}
func (Post) IsEntity() {}

type PostConnection struct {
	Edges    []*PostEdge     `json:"edges"`
	PageInfo *relay.PageInfo `json:"pageInfo"`
}

// Represents content for a post.
type PostContent struct {
	// The ID of this content.
	ID relay.ID `json:"id"`
	// The resource belonging to this content.
	Resource *graphql1.Resource `json:"resource"`
	// The resource for the supporter-only content.
	//
	// If "viewerCanViewSupporterOnlyContent" is false, then this field will contain the original resource, with the URLs omitted. This allows you to use the details, such as the type (since the resource in the "resource" box will always be an image) or see the duration of the video.
	//
	// This field will be nil if "viewerCanViewSupporterOnlyContent" is true
	SupporterOnlyResource *graphql1.Resource `json:"supporterOnlyResource"`
	// Whether or not this content is supporter only.
	IsSupporterOnly bool `json:"isSupporterOnly"`
	// Whether or not the viewer is able to see this content.
	ViewerCanViewSupporterOnlyContent bool `json:"viewerCanViewSupporterOnlyContent"`
}

type PostEdge struct {
	Cursor string `json:"cursor"`
	Node   *Post  `json:"node"`
}

type PostLike struct {
	// An ID uniquely identifying this like.
	ID relay.ID `json:"id"`
	// The time and date at which the post was liked.
	LikedAt time.Time `json:"likedAt"`
	// The post this like belongs to.
	Post *Post `json:"post"`
	// The account this like belongs to
	Account *Account `json:"account"`
}

func (PostLike) IsNode()   {}
func (PostLike) IsEntity() {}

// Update alias slug to default.
type PromoteClubSlugAliasToDefaultInput struct {
	// The club to update
	ID relay.ID `json:"id"`
	// The chosen slug for the club.
	Slug string `json:"slug"`
}

// Payload for a new alt slug
type PromoteClubSlugAliasToDefaultPayload struct {
	// The club after update
	Club *Club `json:"club"`
}

// Update category.
type RemoveCategoryAlternativeTitleInput struct {
	// The category to update
	ID relay.ID `json:"id"`
	// The title to remove.
	Title string `json:"title"`
}

// Payload for updating category
type RemoveCategoryAlternativeTitlePayload struct {
	// The category after update
	Category *Category `json:"category"`
}

// Remove alias slug.
type RemoveClubSlugAliasInput struct {
	// The club to update
	ID relay.ID `json:"id"`
	// The chosen slug for the club.
	Slug string `json:"slug"`
}

// Payload for a new alt slug
type RemoveClubSlugAliasPayload struct {
	// The club after update
	Club *Club `json:"club"`
}

// Remove post content.
type RemovePostContentInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// Content IDs for the content
	ContentIds []relay.ID `json:"contentIds"`
}

// Payload for updating a post
type RemovePostContentPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// A roulette game state.
type RouletteGameState struct {
	// An ID used to uniquely identify this game state.
	ID relay.ID `json:"id"`
	// The first dice that was created.
	DiceOne int `json:"diceOne"`
	// The second dice that was created.
	DiceTwo int `json:"diceTwo"`
	// The third dice that was created.
	DiceThree int `json:"diceThree"`
	// The post that was selected.
	Post *Post `json:"post"`
}

// The status of the roulette game.
type RouletteStatus struct {
	// The game session that this roulette belongs to.
	GameSession *GameSession `json:"gameSession"`
	// The current state of the roulette game. If no spins happened yet, this is nil. Should be used to resume the current roulette session.
	GameState *RouletteGameState `json:"gameState"`
	// How many rolls occurred. Note that this is 0 if the game session is not closed.
	TotalRolls int `json:"totalRolls"`
	// How many doubles occurred. Note that this is 0 if the game session is not closed.
	TotalDoubles int `json:"totalDoubles"`
	// The total score. Note that this is 0 if the game session is not closed.
	Score int `json:"score"`
}

func (RouletteStatus) IsGameSessionStatus() {}

type SearchConnection struct {
	Edges    []*SearchEdge   `json:"edges"`
	PageInfo *relay.PageInfo `json:"pageInfo"`
}

type SearchEdge struct {
	Cursor string `json:"cursor"`
	Node   Search `json:"node"`
}

type Series struct {
	// An ID pointing to this series.
	ID relay.ID `json:"id"`
	// An ID that can be used to uniquely-identify this series. Never changes.
	Reference string `json:"reference"`
	// A url-friendly ID. Should be used when searching
	Slug string `json:"slug"`
	// A URL pointing to the object's thumbnail.
	Thumbnail *graphql1.Resource `json:"thumbnail"`
	// A URL pointing to the object's banner.
	Banner *graphql1.Resource `json:"banner"`
	// A title for this series.
	//
	// Optionally pass a locale to display it in a specific language. English by default.
	Title string `json:"title"`
	// All translations for this title.
	TitleTranslations []*graphql1.Translation `json:"titleTranslations"`
	// Total amount of likes.
	TotalLikes int `json:"totalLikes"`
	// Total amount of posts.
	TotalPosts int `json:"totalPosts"`
	// Get or search all characters for this series.
	Characters *CharacterConnection `json:"characters"`
	// Posts belonging to this series
	Posts *PostConnection `json:"posts"`
}

func (Series) IsSearch() {}
func (Series) IsNode()   {}
func (Series) IsEntity() {}

type SeriesConnection struct {
	Edges    []*SeriesEdge   `json:"edges"`
	PageInfo *relay.PageInfo `json:"pageInfo"`
}

type SeriesEdge struct {
	Cursor string  `json:"cursor"`
	Node   *Series `json:"node"`
}

// Spin roulette.
type SpinRouletteInput struct {
	// The game session ID to use for the spin.
	GameSessionID relay.ID `json:"gameSessionId"`
}

// Payload for spinning roulette.
type SpinRoulettePayload struct {
	// The new roulette spin game state
	RouletteGameState *RouletteGameState `json:"rouletteGameState"`
}

// Publish post.
type SubmitPostInput struct {
	// The post to publish
	ID relay.ID `json:"id"`
}

// Payload for submitting a post
type SubmitPostPayload struct {
	// The post after being submitted
	Post *Post `json:"post"`
}

// Suspend the club.
type SuspendClubInput struct {
	// The club to suspend.
	ClubID relay.ID `json:"clubId"`
	// When the suspension should end.
	EndTime time.Time `json:"endTime"`
}

// Suspend club payload.
type SuspendClubPayload struct {
	// The new club after it's suspended.
	Club *Club `json:"club"`
}

// Terminate the club.
type TerminateClubInput struct {
	// The club to terminate.
	ClubID relay.ID `json:"clubId"`
}

// Terminate club payload.
type TerminateClubPayload struct {
	// The new club after it's terminated.
	Club *Club `json:"club"`
}

type Topic struct {
	// An ID pointing to this topic.
	ID relay.ID `json:"id"`
	// An ID that can be used to uniquely-identify this category. Never changes.
	Reference string `json:"reference"`
	// A url-friendly ID. Should be used when searching
	Slug string `json:"slug"`
	// A URL pointing to the object's banner.
	Banner *graphql1.Resource `json:"banner"`
	// A title for this topic.
	//
	// Optionally pass a locale to display it in a specific language. English by default.
	Title string `json:"title"`
	// All translations for this title.
	TitleTranslations []*graphql1.Translation `json:"titleTranslations"`
	// A description for this topic.
	//
	// Optionally pass a locale to display it in a specific language. English by default.
	Description string `json:"description"`
	// All translations for this topic.
	DescriptionTranslations []*graphql1.Translation `json:"descriptionTranslations"`
	// The weight of this topic.
	Weight int `json:"weight"`
	// All categories linked to this topic.
	Categories *CategoryConnection `json:"categories"`
}

func (Topic) IsNode()   {}
func (Topic) IsEntity() {}

type TopicConnection struct {
	Edges    []*TopicEdge    `json:"edges"`
	PageInfo *relay.PageInfo `json:"pageInfo"`
}

type TopicEdge struct {
	Cursor string `json:"cursor"`
	Node   *Topic `json:"node"`
}

// Transfer club ownership input.
type TransferClubOwnershipInput struct {
	// The club to transfer ownership for.
	ClubID relay.ID `json:"clubId"`
	// The new account that should be the owner of the club.
	AccountID relay.ID `json:"accountId"`
}

// Transfer club ownership.
type TransferClubOwnershipPayload struct {
	// The new club after ownership has been transferred.
	Club *Club `json:"club"`
}

// Un-Archive post.
type UnArchivePostInput struct {
	// The post to un-archive
	ID relay.ID `json:"id"`
}

// Payload for un-archiving a post
type UnArchivePostPayload struct {
	// The un-archived post.
	Post *Post `json:"post"`
}

// Un-Suspend the club.
type UnSuspendClubInput struct {
	// The club to un-suspend.
	ClubID relay.ID `json:"clubId"`
}

// Un suspend club payload.
type UnSuspendClubPayload struct {
	// The new club after it's not suspended anymore.
	Club *Club `json:"club"`
}

// Un-Terminate the club.
type UnTerminateClubInput struct {
	// The club to un-terminate.
	ClubID relay.ID `json:"clubId"`
}

// Un terminate club payload.
type UnTerminateClubPayload struct {
	// The new club after it's not terminated anymore.
	Club *Club `json:"club"`
}

// Undo like on a post.
type UndoLikePostInput struct {
	// The post ID that you want to unlike
	ID relay.ID `json:"id"`
}

// Payload for undoing a post like
type UndoLikePostPayload struct {
	// The post like that was deleted.
	PostLikeID *relay.ID `json:"postLikeId"`
}

// Update audience.
type UpdateAudienceBannerInput struct {
	// The audience to update
	ID relay.ID `json:"id"`
	// The banner
	Banner string `json:"banner"`
}

// Payload for updating audience
type UpdateAudienceBannerPayload struct {
	// The audience after update
	Audience *Audience `json:"audience"`
}

// Update audience.
type UpdateAudienceIsStandardInput struct {
	// The audience to update
	ID relay.ID `json:"id"`
	// Standard
	Standard bool `json:"standard"`
}

// Payload for updating audience
type UpdateAudienceIsStandardPayload struct {
	// The audience after update
	Audience *Audience `json:"audience"`
}

// Update audience.
type UpdateAudienceThumbnailInput struct {
	// The audience to update
	ID relay.ID `json:"id"`
	// The thumbnail
	Thumbnail string `json:"thumbnail"`
}

// Payload for updating audience
type UpdateAudienceThumbnailPayload struct {
	// The audience after update
	Audience *Audience `json:"audience"`
}

// Update audience.
type UpdateAudienceTitleInput struct {
	// The audience to update
	ID relay.ID `json:"id"`
	// The title to update.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// The localization for this title
	Locale string `json:"locale"`
}

// Payload for updating audience
type UpdateAudienceTitlePayload struct {
	// The audience after update
	Audience *Audience `json:"audience"`
}

// Update category.
type UpdateCategoryThumbnailInput struct {
	// The category to update
	ID relay.ID `json:"id"`
	// The thumbnail
	Thumbnail string `json:"thumbnail"`
}

// Payload for updating category
type UpdateCategoryThumbnailPayload struct {
	// The category after update
	Category *Category `json:"category"`
}

// Update category.
type UpdateCategoryTitleInput struct {
	// The category to update
	ID relay.ID `json:"id"`
	// The title to update.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// The localization for this title
	Locale string `json:"locale"`
}

// Payload for updating category
type UpdateCategoryTitlePayload struct {
	// The category after update
	Category *Category `json:"category"`
}

// Update category topic.
type UpdateCategoryTopicInput struct {
	// The category to update
	ID relay.ID `json:"id"`
	// The topic to assign to this category.
	TopicID relay.ID `json:"topicId"`
}

// Payload for updating category
type UpdateCategoryTopicPayload struct {
	// The category after update
	Category *Category `json:"category"`
}

// Update character.
type UpdateCharacterNameInput struct {
	// The character to update
	ID relay.ID `json:"id"`
	// The name to update.
	//
	// Validation: Max 25 characters.
	Name string `json:"name"`
	// The localization for this name.
	//
	// Validation: Must be one of the languages from the languages query.
	Locale string `json:"locale"`
}

// Payload for updating character
type UpdateCharacterNamePayload struct {
	// The character after update
	Character *Character `json:"character"`
}

// Update character.
type UpdateCharacterThumbnailInput struct {
	// The character to update
	ID relay.ID `json:"id"`
	// The thumbnail
	Thumbnail string `json:"thumbnail"`
}

// Payload for updating character
type UpdateCharacterThumbnailPayload struct {
	// The character after update
	Character *Character `json:"character"`
}

// Update club characters limit.
type UpdateClubCharactersLimitInput struct {
	// The club to update club characters limit for.
	ClubID relay.ID `json:"clubId"`
	// The amount of characters the club will be able to create.
	//
	// Validation: Limit to 200.
	CharactersLimit int `json:"charactersLimit"`
}

// Update club characters limit payload.
type UpdateClubCharactersLimitPayload struct {
	// The club after updating the characters limit.
	Club *Club `json:"club"`
}

// Update club name.
type UpdateClubNameInput struct {
	// The club to update
	ID relay.ID `json:"id"`
	// The chosen name for the club.
	//
	// Validation: Max 25 characters.
	Name string `json:"name"`
}

// Payload for updating the name
type UpdateClubNamePayload struct {
	// The club after update
	Club *Club `json:"club"`
}

// Update club thumbnail.
type UpdateClubThumbnailInput struct {
	// The club to update
	ID relay.ID `json:"id"`
	// The thumbnail for the club.
	Thumbnail string `json:"thumbnail"`
}

// Payload for updating the thumbnail
type UpdateClubThumbnailPayload struct {
	// The club after update
	Club *Club `json:"club"`
}

// Update curation profile audience.
type UpdateCurationProfileAudienceInput struct {
	// The audiences that were selected
	AudienceIds []relay.ID `json:"audienceIds"`
	// Whether or not this section was skipped
	Skipped bool `json:"skipped"`
}

// Payload for updating profile audience
type UpdateCurationProfileAudiencePayload struct {
	// The updated profile.
	CurationProfile *CurationProfile `json:"curationProfile"`
}

// Update curation profile category.
type UpdateCurationProfileCategoryInput struct {
	// The categories that were selected
	CategoryIds []relay.ID `json:"categoryIds"`
	// Whether or not this section was skipped
	Skipped bool `json:"skipped"`
}

// Payload for updating profile category
type UpdateCurationProfileCategoryPayload struct {
	// The updated profile.
	CurationProfile *CurationProfile `json:"curationProfile"`
}

// Update curation profile date of birth.
type UpdateCurationProfileDateOfBirthInput struct {
	// The date of birth that was selected
	DateOfBirth *time.Time `json:"dateOfBirth"`
	// Whether or not this section was skipped
	Skipped bool `json:"skipped"`
}

// Payload for updating profile date of birth
type UpdateCurationProfileDateOfBirthPayload struct {
	// The updated profile.
	CurationProfile *CurationProfile `json:"curationProfile"`
}

// Update post audience.
type UpdatePostAudienceInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// The audience that this post belongs to
	AudienceID relay.ID `json:"audienceId"`
}

// Payload for updating a post
type UpdatePostAudiencePayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Update post audience.
type UpdatePostCategoriesInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// Category IDs for this post
	CategoryIds []relay.ID `json:"categoryIds"`
}

// Payload for updating a post
type UpdatePostCategoriesPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Update post characters.
type UpdatePostCharactersInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// Ids for all the characters
	CharacterIds []relay.ID `json:"characterIds"`
}

// Payload for updating a post
type UpdatePostCharactersPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Payload for updating a post
type UpdatePostClubPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Update post content is supporter only.
type UpdatePostContentIsSupporterOnlyInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// Content IDs to update
	ContentIds []relay.ID `json:"contentIds"`
	// The change to make
	IsSupporterOnly bool `json:"isSupporterOnly"`
}

// Payload for updating a post
type UpdatePostContentIsSupporterOnlyPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Update post content order.
type UpdatePostContentOrderInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// Content IDs for the content
	ContentIds []relay.ID `json:"contentIds"`
}

// Payload for updating a post
type UpdatePostContentOrderPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Update post.
type UpdatePostDescriptionInput struct {
	// The post to update
	ID relay.ID `json:"id"`
	// The description to update.
	//
	// Validation: Max 280 characters. No links allowed.
	Description string `json:"description"`
	// The localization for this description.
	//
	// Locale must be one from the languages query, or else the locale won't be accepted.
	Locale string `json:"locale"`
}

// Payload for updating a post description
type UpdatePostDescriptionPayload struct {
	// The post after the update
	Post *Post `json:"post"`
}

// Update series.
type UpdateSeriesThumbnailInput struct {
	// The series to update
	ID relay.ID `json:"id"`
	// The thumbnail
	Thumbnail string `json:"thumbnail"`
}

// Payload for updating series
type UpdateSeriesThumbnailPayload struct {
	// The category after update
	Series *Series `json:"series"`
}

// Update series.
type UpdateSeriesTitleInput struct {
	// The series to update
	ID relay.ID `json:"id"`
	// The title to update.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// The localization for this title.
	//
	// Locale must be one from the languages query, or else the locale won't be accepted.
	Locale string `json:"locale"`
}

// Payload for updating series
type UpdateSeriesTitlePayload struct {
	// The series after update
	Series *Series `json:"series"`
}

// Update topic.
type UpdateTopicBannerInput struct {
	// The category to update
	ID relay.ID `json:"id"`
	// The banner
	Banner string `json:"banner"`
}

// Payload for updating topic
type UpdateTopicBannerPayload struct {
	// The topic after update
	Topic *Topic `json:"topic"`
}

// Update topic.
type UpdateTopicDescriptionInput struct {
	// The topic to update
	ID relay.ID `json:"id"`
	// The description to update.
	//
	// Validation: Markdown allowed.
	Description string `json:"description"`
	// The localization for this description
	Locale string `json:"locale"`
}

// Payload for updating topic
type UpdateTopicDescriptionPayload struct {
	// The topic after update
	Topic *Topic `json:"topic"`
}

// Update topic.
type UpdateTopicTitleInput struct {
	// The topic to update
	ID relay.ID `json:"id"`
	// The title to update.
	//
	// Validation: Max 25 characters.
	Title string `json:"title"`
	// The localization for this title
	Locale string `json:"locale"`
}

// Payload for updating topic
type UpdateTopicTitlePayload struct {
	// The topic after update
	Topic *Topic `json:"topic"`
}

// Update topic.
type UpdateTopicWeightInput struct {
	// The topic to update
	ID relay.ID `json:"id"`
	// The weight to update to.
	Weight int `json:"weight"`
}

// Payload for updating topic
type UpdateTopicWeightPayload struct {
	// The topic after update
	Topic *Topic `json:"topic"`
}

// Validation for adding a new slug to a club
type AddClubSlugAliasValidation string

const (
	AddClubSlugAliasValidationSlugTaken AddClubSlugAliasValidation = "SLUG_TAKEN"
)

var AllAddClubSlugAliasValidation = []AddClubSlugAliasValidation{
	AddClubSlugAliasValidationSlugTaken,
}

func (e AddClubSlugAliasValidation) IsValid() bool {
	switch e {
	case AddClubSlugAliasValidationSlugTaken:
		return true
	}
	return false
}

func (e AddClubSlugAliasValidation) String() string {
	return string(e)
}

func (e *AddClubSlugAliasValidation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AddClubSlugAliasValidation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AddClubSlugAliasValidation", str)
	}
	return nil
}

func (e AddClubSlugAliasValidation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which audience connections can be sorted.
type AudiencesSort string

const (
	// Audience by newest first
	AudiencesSortNew AudiencesSort = "NEW"
	// Audience by top likes
	AudiencesSortTop AudiencesSort = "TOP"
	// Audience by most posts
	AudiencesSortPopular AudiencesSort = "POPULAR"
)

var AllAudiencesSort = []AudiencesSort{
	AudiencesSortNew,
	AudiencesSortTop,
	AudiencesSortPopular,
}

func (e AudiencesSort) IsValid() bool {
	switch e {
	case AudiencesSortNew, AudiencesSortTop, AudiencesSortPopular:
		return true
	}
	return false
}

func (e AudiencesSort) String() string {
	return string(e)
}

func (e *AudiencesSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AudiencesSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AudiencesSort", str)
	}
	return nil
}

func (e AudiencesSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which categories connections can be sorted.
type CategoriesSort string

const (
	// Categories by newest first
	CategoriesSortNew CategoriesSort = "NEW"
	// Categories by top likes
	CategoriesSortTop CategoriesSort = "TOP"
	// Categories by most posts
	CategoriesSortPopular CategoriesSort = "POPULAR"
)

var AllCategoriesSort = []CategoriesSort{
	CategoriesSortNew,
	CategoriesSortTop,
	CategoriesSortPopular,
}

func (e CategoriesSort) IsValid() bool {
	switch e {
	case CategoriesSortNew, CategoriesSortTop, CategoriesSortPopular:
		return true
	}
	return false
}

func (e CategoriesSort) String() string {
	return string(e)
}

func (e *CategoriesSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CategoriesSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CategoriesSort", str)
	}
	return nil
}

func (e CategoriesSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which character connections can be sorted.
type CharactersSort string

const (
	// Characters by newest first
	CharactersSortNew CharactersSort = "NEW"
	// Characters by top likes
	CharactersSortTop CharactersSort = "TOP"
	// Characters by most posts
	CharactersSortPopular CharactersSort = "POPULAR"
)

var AllCharactersSort = []CharactersSort{
	CharactersSortNew,
	CharactersSortTop,
	CharactersSortPopular,
}

func (e CharactersSort) IsValid() bool {
	switch e {
	case CharactersSortNew, CharactersSortTop, CharactersSortPopular:
		return true
	}
	return false
}

func (e CharactersSort) String() string {
	return string(e)
}

func (e *CharactersSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharactersSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharactersSort", str)
	}
	return nil
}

func (e CharactersSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which club member connections can be sorted.
type ClubMembersSort string

const (
	// By oldest members
	ClubMembersSortNewest ClubMembersSort = "NEWEST"
)

var AllClubMembersSort = []ClubMembersSort{
	ClubMembersSortNewest,
}

func (e ClubMembersSort) IsValid() bool {
	switch e {
	case ClubMembersSortNewest:
		return true
	}
	return false
}

func (e ClubMembersSort) String() string {
	return string(e)
}

func (e *ClubMembersSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClubMembersSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClubMembersSort", str)
	}
	return nil
}

func (e ClubMembersSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reasons a club suspension was created.
type ClubSuspensionReason string

const (
	// Suspension was issued from a post moderation queue.
	ClubSuspensionReasonPostModerationQueue ClubSuspensionReason = "POST_MODERATION_QUEUE"
	// Suspension was issued from a post removal.
	ClubSuspensionReasonPostRemoval ClubSuspensionReason = "POST_REMOVAL"
	// Suspension was issued manually.
	ClubSuspensionReasonManual ClubSuspensionReason = "MANUAL"
)

var AllClubSuspensionReason = []ClubSuspensionReason{
	ClubSuspensionReasonPostModerationQueue,
	ClubSuspensionReasonPostRemoval,
	ClubSuspensionReasonManual,
}

func (e ClubSuspensionReason) IsValid() bool {
	switch e {
	case ClubSuspensionReasonPostModerationQueue, ClubSuspensionReasonPostRemoval, ClubSuspensionReasonManual:
		return true
	}
	return false
}

func (e ClubSuspensionReason) String() string {
	return string(e)
}

func (e *ClubSuspensionReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClubSuspensionReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClubSuspensionReason", str)
	}
	return nil
}

func (e ClubSuspensionReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which club connections can be sorted.
type ClubsSort string

const (
	// Clubs by popularity
	ClubsSortPopular ClubsSort = "POPULAR"
)

var AllClubsSort = []ClubsSort{
	ClubsSortPopular,
}

func (e ClubsSort) IsValid() bool {
	switch e {
	case ClubsSortPopular:
		return true
	}
	return false
}

func (e ClubsSort) String() string {
	return string(e)
}

func (e *ClubsSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ClubsSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ClubsSort", str)
	}
	return nil
}

func (e ClubsSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation for creating a new audience
type CreateAudienceValidation string

const (
	CreateAudienceValidationSlugTaken CreateAudienceValidation = "SLUG_TAKEN"
)

var AllCreateAudienceValidation = []CreateAudienceValidation{
	CreateAudienceValidationSlugTaken,
}

func (e CreateAudienceValidation) IsValid() bool {
	switch e {
	case CreateAudienceValidationSlugTaken:
		return true
	}
	return false
}

func (e CreateAudienceValidation) String() string {
	return string(e)
}

func (e *CreateAudienceValidation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateAudienceValidation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateAudienceValidation", str)
	}
	return nil
}

func (e CreateAudienceValidation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation for creating a new category
type CreateCategoryValidation string

const (
	CreateCategoryValidationSlugTaken CreateCategoryValidation = "SLUG_TAKEN"
)

var AllCreateCategoryValidation = []CreateCategoryValidation{
	CreateCategoryValidationSlugTaken,
}

func (e CreateCategoryValidation) IsValid() bool {
	switch e {
	case CreateCategoryValidationSlugTaken:
		return true
	}
	return false
}

func (e CreateCategoryValidation) String() string {
	return string(e)
}

func (e *CreateCategoryValidation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateCategoryValidation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateCategoryValidation", str)
	}
	return nil
}

func (e CreateCategoryValidation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation for creating a new character
type CreateCharacterValidation string

const (
	CreateCharacterValidationSlugTaken CreateCharacterValidation = "SLUG_TAKEN"
)

var AllCreateCharacterValidation = []CreateCharacterValidation{
	CreateCharacterValidationSlugTaken,
}

func (e CreateCharacterValidation) IsValid() bool {
	switch e {
	case CreateCharacterValidationSlugTaken:
		return true
	}
	return false
}

func (e CreateCharacterValidation) String() string {
	return string(e)
}

func (e *CreateCharacterValidation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateCharacterValidation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateCharacterValidation", str)
	}
	return nil
}

func (e CreateCharacterValidation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation for creating a new club
type CreateClubValidation string

const (
	CreateClubValidationSlugTaken CreateClubValidation = "SLUG_TAKEN"
)

var AllCreateClubValidation = []CreateClubValidation{
	CreateClubValidationSlugTaken,
}

func (e CreateClubValidation) IsValid() bool {
	switch e {
	case CreateClubValidationSlugTaken:
		return true
	}
	return false
}

func (e CreateClubValidation) String() string {
	return string(e)
}

func (e *CreateClubValidation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateClubValidation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateClubValidation", str)
	}
	return nil
}

func (e CreateClubValidation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation for creating a new series
type CreateSeriesValidation string

const (
	CreateSeriesValidationSlugTaken CreateSeriesValidation = "SLUG_TAKEN"
)

var AllCreateSeriesValidation = []CreateSeriesValidation{
	CreateSeriesValidationSlugTaken,
}

func (e CreateSeriesValidation) IsValid() bool {
	switch e {
	case CreateSeriesValidationSlugTaken:
		return true
	}
	return false
}

func (e CreateSeriesValidation) String() string {
	return string(e)
}

func (e *CreateSeriesValidation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateSeriesValidation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateSeriesValidation", str)
	}
	return nil
}

func (e CreateSeriesValidation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation for creating a new topic
type CreateTopicValidation string

const (
	CreateTopicValidationSlugTaken CreateTopicValidation = "SLUG_TAKEN"
)

var AllCreateTopicValidation = []CreateTopicValidation{
	CreateTopicValidationSlugTaken,
}

func (e CreateTopicValidation) IsValid() bool {
	switch e {
	case CreateTopicValidationSlugTaken:
		return true
	}
	return false
}

func (e CreateTopicValidation) String() string {
	return string(e)
}

func (e *CreateTopicValidation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreateTopicValidation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreateTopicValidation", str)
	}
	return nil
}

func (e CreateTopicValidation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types of games available.
type GameType string

const (
	GameTypeRoulette GameType = "ROULETTE"
)

var AllGameType = []GameType{
	GameTypeRoulette,
}

func (e GameType) IsValid() bool {
	switch e {
	case GameTypeRoulette:
		return true
	}
	return false
}

func (e GameType) String() string {
	return string(e)
}

func (e *GameType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GameType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GameType", str)
	}
	return nil
}

func (e GameType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostState string

const (
	PostStateDraft     PostState = "DRAFT"
	PostStateReview    PostState = "REVIEW"
	PostStatePublished PostState = "PUBLISHED"
	PostStateDiscarded PostState = "DISCARDED"
	PostStateRejected  PostState = "REJECTED"
	PostStateRemoved   PostState = "REMOVED"
	PostStateArchived  PostState = "ARCHIVED"
)

var AllPostState = []PostState{
	PostStateDraft,
	PostStateReview,
	PostStatePublished,
	PostStateDiscarded,
	PostStateRejected,
	PostStateRemoved,
	PostStateArchived,
}

func (e PostState) IsValid() bool {
	switch e {
	case PostStateDraft, PostStateReview, PostStatePublished, PostStateDiscarded, PostStateRejected, PostStateRemoved, PostStateArchived:
		return true
	}
	return false
}

func (e PostState) String() string {
	return string(e)
}

func (e *PostState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostState", str)
	}
	return nil
}

func (e PostState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which posts connections can be sorted.
type PostsSort string

const (
	// Posts by newest first
	PostsSortNew PostsSort = "NEW"
	// Posts by top likes
	PostsSortTop PostsSort = "TOP"
	// Posts by algorithm sort
	PostsSortAlgorithm PostsSort = "ALGORITHM"
)

var AllPostsSort = []PostsSort{
	PostsSortNew,
	PostsSortTop,
	PostsSortAlgorithm,
}

func (e PostsSort) IsValid() bool {
	switch e {
	case PostsSortNew, PostsSortTop, PostsSortAlgorithm:
		return true
	}
	return false
}

func (e PostsSort) String() string {
	return string(e)
}

func (e *PostsSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostsSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostsSort", str)
	}
	return nil
}

func (e PostsSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which series connections can be sorted.
type SeriesSort string

const (
	// Series by newest first
	SeriesSortNew SeriesSort = "NEW"
	// Series by top likes
	SeriesSortTop SeriesSort = "TOP"
	// Series by most posts
	SeriesSortPopular SeriesSort = "POPULAR"
)

var AllSeriesSort = []SeriesSort{
	SeriesSortNew,
	SeriesSortTop,
	SeriesSortPopular,
}

func (e SeriesSort) IsValid() bool {
	switch e {
	case SeriesSortNew, SeriesSortTop, SeriesSortPopular:
		return true
	}
	return false
}

func (e SeriesSort) String() string {
	return string(e)
}

func (e *SeriesSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SeriesSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SeriesSort", str)
	}
	return nil
}

func (e SeriesSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SupporterOnlyStatus string

const (
	// None of the content requires supporting to view.
	SupporterOnlyStatusNone SupporterOnlyStatus = "NONE"
	// Some of the content requires supporting to view, at least 1 content piece is free.
	SupporterOnlyStatusPartial SupporterOnlyStatus = "PARTIAL"
	// All of the content is supporter-only.
	SupporterOnlyStatusFull SupporterOnlyStatus = "FULL"
)

var AllSupporterOnlyStatus = []SupporterOnlyStatus{
	SupporterOnlyStatusNone,
	SupporterOnlyStatusPartial,
	SupporterOnlyStatusFull,
}

func (e SupporterOnlyStatus) IsValid() bool {
	switch e {
	case SupporterOnlyStatusNone, SupporterOnlyStatusPartial, SupporterOnlyStatusFull:
		return true
	}
	return false
}

func (e SupporterOnlyStatus) String() string {
	return string(e)
}

func (e *SupporterOnlyStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SupporterOnlyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SupporterOnlyStatus", str)
	}
	return nil
}

func (e SupporterOnlyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
