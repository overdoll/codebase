package scan

import (
	"context"
	"log"
	"math"
	"strings"

	"github.com/scylladb/gocqlx/v2"
	"github.com/scylladb/gocqlx/v2/table"
	"golang.org/x/sync/errgroup"
)

// Scan is a package that makes full table scanning easier, in order to repopulate broken indexes or creating new indexes
// taken from: https://www.scylladb.com/2017/02/13/efficient-full-table-scans-with-scylla-1-6/

type Scan struct {
	config  Config
	session gocqlx.Session
}

type Config struct {
	NodesInCluster int
	CoresInNode    int
	SmudgeFactor   int
}

func New(session gocqlx.Session, config Config) *Scan {
	return &Scan{config: config, session: session}
}

func (s *Scan) RunIterator(ctx context.Context, table *table.Table, run func(iter *gocqlx.Iterx) error) error {

	workers := s.config.NodesInCluster * s.config.CoresInNode * s.config.SmudgeFactor

	type tokenRange struct {
		Start int64
		End   int64
	}
	buf := make(chan tokenRange)

	// sequencer pushes token ranges to buf
	sequencer := func() error {
		span := int64(math.MaxInt64 / (50 * workers))

		tr := tokenRange{math.MinInt64, math.MinInt64 + span}
		for tr.End > tr.Start {
			buf <- tr
			tr.Start = tr.End
			tr.End += span
		}

		tr.End = math.MaxInt64
		buf <- tr
		close(buf)

		return nil
	}

	// worker queries a token ranges generated by sequencer
	worker := func() error {

		partitionKey := strings.Join(table.Metadata().PartKey, ",")

		var cql = `SELECT * FROM ` + table.Name() + ` WHERE 
			token(` + partitionKey + `) >= :start AND 
			token(` + partitionKey + `) < :end`

		stmt, names, err := gocqlx.CompileNamedQueryString(cql)
		if err != nil {
			return err
		}

		q := s.session.Query(stmt, names)
		defer q.Release()

		for {
			tr, ok := <-buf
			if !ok {
				break
			}

			iter := q.BindStruct(tr).Iter()

			if err := run(iter); err != nil {
				_ = iter.Close()
				log.Fatalf("error with iterator: %v", err)
				return err
			}

			if err := iter.Close(); err != nil {
				log.Fatalf("error with closing iterator: %v", err)
				return err
			}
		}

		return nil
	}

	// Query and displays data.

	var wg errgroup.Group

	wg.Go(sequencer)
	for i := 0; i < workers; i++ {
		wg.Go(worker)
	}

	if err := wg.Wait(); err != nil {
		return err
	}

	return nil
}
